//! Octonion-valued scalar field on a 1D periodic lattice.
//!
//! Restricts to the octonionic subalgebra of the Cayley-Dickson tower to
//! bypass the sedenion non-associativity obstruction (C-030). Octonions
//! are alternative: every subalgebra generated by two elements is
//! associative, guaranteeing consistent Lagrangians for power-type potentials.
//!
//! Lagrangian density (1+1D, M=1):
//!   L = (1/2)||dphi/dt||^2 - (1/2)||dphi/dx||^2 - (1/2)m^2||phi||^2
//!       - (lambda/4)||phi||^4
//!
//! Symplectic integrator: Stormer-Verlet (second-order, time-reversible).
//!
//! # Literature
//! - Dixon (1994), Division Algebras: Octonions, Quaternions...
//! - Tze & Nam (1989), Ann. Phys. 193, 419

use std::f64::consts::PI;

/// Fano plane structure constants.
///
/// Oriented triples (i,j,k): e_i * e_j = +e_k (cyclic).
pub const FANO_TRIPLES: [(usize, usize, usize); 7] = [
    (1, 2, 3),
    (1, 4, 5),
    (1, 7, 6),
    (2, 4, 6),
    (2, 5, 7),
    (3, 4, 7),
    (3, 6, 5),
];

/// Octonion (8 components: 1 real + 7 imaginary).
pub type Octonion = [f64; 8];

/// Build structure constant table from Fano plane.
///
/// Returns table[i][j] = (sign, k) for e_i * e_j = sign * e_k.
pub fn build_structure_constants() -> [[Option<(i8, usize)>; 8]; 8] {
    let mut sc = [[None; 8]; 8];

    for (p, q, r) in FANO_TRIPLES {
        sc[p][q] = Some((1, r));
        sc[q][r] = Some((1, p));
        sc[r][p] = Some((1, q));
        sc[q][p] = Some((-1, r));
        sc[r][q] = Some((-1, p));
        sc[p][r] = Some((-1, q));
    }

    sc
}

/// Multiply two octonions.
pub fn oct_multiply(a: &Octonion, b: &Octonion) -> Octonion {
    let sc = build_structure_constants();
    let mut out = [0.0; 8];

    // Real part: a0*b0 - sum_{i>0} a_i*b_i
    out[0] = a[0] * b[0];
    for i in 1..8 {
        out[0] -= a[i] * b[i];
    }

    // e_0*e_i and e_i*e_0 contributions
    for i in 1..8 {
        out[i] = a[0] * b[i] + a[i] * b[0];
    }

    // Cross terms from Fano-plane structure constants
    for i in 1..8 {
        for j in 1..8 {
            if let Some((sign, k)) = sc[i][j] {
                out[k] += sign as f64 * a[i] * b[j];
            }
        }
    }

    out
}

/// Conjugate an octonion (negate imaginary parts).
pub fn oct_conjugate(a: &Octonion) -> Octonion {
    let mut out = *a;
    for val in out.iter_mut().skip(1) {
        *val = -*val;
    }
    out
}

/// Squared norm of an octonion: ||a||^2 = sum a_i^2.
pub fn oct_norm_sq(a: &Octonion) -> f64 {
    a.iter().map(|x| x * x).sum()
}

/// Result from field evolution.
#[derive(Clone, Debug)]
pub struct EvolutionResult {
    /// Final field configuration (N x 8)
    pub phi: Vec<Octonion>,
    /// Final conjugate momentum (N x 8)
    pub pi: Vec<Octonion>,
    /// Energy at each time step
    pub energies: Vec<f64>,
    /// Initial Noether charges
    pub charges_initial: [f64; 7],
    /// Final Noether charges
    pub charges_final: [f64; 7],
}

/// Parameters for field simulation.
#[derive(Clone, Debug)]
pub struct FieldParams {
    /// Number of lattice sites
    pub n: usize,
    /// Domain length (periodic)
    pub l: f64,
    /// Scalar mass
    pub mass: f64,
    /// Quartic coupling
    pub coupling: f64,
    /// Time step
    pub dt: f64,
}

impl Default for FieldParams {
    fn default() -> Self {
        Self {
            n: 64,
            l: 2.0 * PI,
            mass: 1.0,
            coupling: 0.0,
            dt: 0.01,
        }
    }
}

/// Discrete Hamiltonian for the lattice field.
///
/// H = (1/2) sum ||pi_i||^2
///   + (1/(2*dx^2)) sum ||phi_{i+1} - phi_i||^2
///   + (m^2/2) sum ||phi_i||^2
///   + (lambda/4) sum ||phi_i||^4
pub fn hamiltonian(phi: &[Octonion], pi: &[Octonion], params: &FieldParams) -> f64 {
    let n = phi.len();
    let dx = params.l / n as f64;

    // Kinetic energy
    let t: f64 = pi.iter().map(oct_norm_sq).sum::<f64>() * 0.5;

    // Gradient energy
    let mut v_grad = 0.0;
    for i in 0..n {
        let j = (i + 1) % n;
        #[allow(clippy::needless_range_loop)]
        for k in 0..8 {
            let diff = phi[j][k] - phi[i][k];
            v_grad += diff * diff;
        }
    }
    v_grad *= 0.5 / (dx * dx);

    // Mass term
    let v_mass: f64 = phi.iter().map(oct_norm_sq).sum::<f64>() * 0.5 * params.mass * params.mass;

    // Quartic interaction
    let v_int = if params.coupling != 0.0 {
        let sum_norm4: f64 = phi.iter().map(|p| oct_norm_sq(p).powi(2)).sum();
        0.25 * params.coupling * sum_norm4
    } else {
        0.0
    };

    t + v_grad + v_mass + v_int
}

/// Force at each lattice site: f_i = -dV/dphi_i.
pub fn force(phi: &[Octonion], params: &FieldParams) -> Vec<Octonion> {
    let n = phi.len();
    let dx = params.l / n as f64;
    let dx2 = dx * dx;

    let mut f: Vec<Octonion> = vec![[0.0; 8]; n];

    for i in 0..n {
        let prev = if i == 0 { n - 1 } else { i - 1 };
        let next = (i + 1) % n;

        // Laplacian: (phi_{i+1} + phi_{i-1} - 2*phi_i) / dx^2
        for k in 0..8 {
            let lap = (phi[next][k] + phi[prev][k] - 2.0 * phi[i][k]) / dx2;
            f[i][k] = lap - params.mass * params.mass * phi[i][k];
        }

        // Quartic term: -lambda * ||phi||^2 * phi
        if params.coupling != 0.0 {
            let norm_sq = oct_norm_sq(&phi[i]);
            for k in 0..8 {
                f[i][k] -= params.coupling * norm_sq * phi[i][k];
            }
        }
    }

    f
}

/// One Stormer-Verlet (leapfrog) step, second-order symplectic.
pub fn stormer_verlet_step(
    phi: &mut [Octonion],
    pi: &mut [Octonion],
    params: &FieldParams,
) {
    let n = phi.len();
    let dt = params.dt;

    // Half-step momentum update
    let f = force(phi, params);
    for i in 0..n {
        for k in 0..8 {
            pi[i][k] += 0.5 * dt * f[i][k];
        }
    }

    // Full-step position update
    for i in 0..n {
        for k in 0..8 {
            phi[i][k] += dt * pi[i][k];
        }
    }

    // Half-step momentum update
    let f = force(phi, params);
    for i in 0..n {
        for k in 0..8 {
            pi[i][k] += 0.5 * dt * f[i][k];
        }
    }
}

/// Compute the 7 Noether charges from octonionic U(1) rotations.
///
/// Q_k = sum_i pi_i . (e_k * phi_i) for k = 1..7.
pub fn noether_charges(phi: &[Octonion], pi: &[Octonion]) -> [f64; 7] {
    let n = phi.len();
    let mut charges = [0.0; 7];

    for k in 1..8 {
        let mut e_k = [0.0; 8];
        e_k[k] = 1.0;

        let mut q = 0.0;
        for i in 0..n {
            let rotated = oct_multiply(&e_k, &phi[i]);
            for j in 0..8 {
                q += pi[i][j] * rotated[j];
            }
        }
        charges[k - 1] = q;
    }

    charges
}

/// Evolve the field for n_steps and return results.
pub fn evolve(
    phi0: &[Octonion],
    pi0: &[Octonion],
    params: &FieldParams,
    n_steps: usize,
) -> EvolutionResult {
    let mut phi = phi0.to_vec();
    let mut pi = pi0.to_vec();

    let charges_initial = noether_charges(&phi, &pi);
    let mut energies = Vec::with_capacity(n_steps + 1);
    energies.push(hamiltonian(&phi, &pi, params));

    for _ in 0..n_steps {
        stormer_verlet_step(&mut phi, &mut pi, params);
        energies.push(hamiltonian(&phi, &pi, params));
    }

    let charges_final = noether_charges(&phi, &pi);

    EvolutionResult {
        phi,
        pi,
        energies,
        charges_initial,
        charges_final,
    }
}

/// Initialize a Gaussian wave packet.
pub fn gaussian_wave_packet(params: &FieldParams) -> (Vec<Octonion>, Vec<Octonion>) {
    let n = params.n;
    let l = params.l;
    let dx = l / n as f64;
    let sigma = l / 8.0;

    let mut phi = vec![[0.0; 8]; n];
    let mut pi = vec![[0.0; 8]; n];

    for i in 0..n {
        let x = i as f64 * dx;
        let envelope = (-0.5 * ((x - l / 2.0) / sigma).powi(2)).exp();
        phi[i][0] = envelope * (4.0 * x).cos();
        phi[i][1] = envelope * (4.0 * x).sin();
        pi[i][0] = -0.5 * envelope * (4.0 * x).sin();
        pi[i][1] = 0.5 * envelope * (4.0 * x).cos();
    }

    (phi, pi)
}

/// Initialize a standing wave in e_1 direction.
pub fn standing_wave(params: &FieldParams, mode: usize, amplitude: f64) -> (Vec<Octonion>, Vec<Octonion>) {
    let n = params.n;
    let l = params.l;
    let dx = l / n as f64;
    let k = 2.0 * PI * mode as f64 / l;

    let mut phi = vec![[0.0; 8]; n];
    let pi = vec![[0.0; 8]; n];

    #[allow(clippy::needless_range_loop)]
    for i in 0..n {
        let x = i as f64 * dx;
        phi[i][1] = amplitude * (k * x).sin();
    }

    (phi, pi)
}

/// Measure dispersion relation for a given mode.
#[derive(Clone, Debug)]
pub struct DispersionResult {
    pub mode: usize,
    pub k: f64,
    pub omega_exact: f64,
    pub omega_measured: f64,
    pub rel_error: f64,
}

/// Measure dispersion relation for the first n_modes modes.
pub fn measure_dispersion(params: &FieldParams, n_modes: usize) -> Vec<DispersionResult> {
    let mut results = Vec::with_capacity(n_modes);

    for mode in 1..=n_modes {
        let k = 2.0 * PI * mode as f64 / params.l;
        let omega_exact = (k * k + params.mass * params.mass).sqrt();
        let t_period = 2.0 * PI / omega_exact;

        let mut mode_params = params.clone();
        mode_params.dt = t_period / 200.0;
        let n_steps = (4.0 * t_period / mode_params.dt) as usize;

        let (phi0, pi0) = standing_wave(&mode_params, mode, 0.1);
        let idx = (mode_params.n / (4 * mode)).max(1);

        let mut phi = phi0.clone();
        let mut pi = pi0.clone();
        let mut amplitudes = Vec::with_capacity(n_steps + 1);
        amplitudes.push(phi[idx][1]);

        for _ in 0..n_steps {
            stormer_verlet_step(&mut phi, &mut pi, &mode_params);
            amplitudes.push(phi[idx][1]);
        }

        // FFT to find peak frequency
        let omega_measured = fft_peak_frequency(&amplitudes, mode_params.dt);

        let rel_error = (omega_measured - omega_exact).abs() / omega_exact;

        results.push(DispersionResult {
            mode,
            k,
            omega_exact,
            omega_measured,
            rel_error,
        });
    }

    results
}

/// Simple FFT peak frequency finder (using real FFT approximation).
fn fft_peak_frequency(signal: &[f64], dt: f64) -> f64 {
    use rustfft::FftPlanner;
    use num_complex::Complex64;

    let n = signal.len();
    let mut planner = FftPlanner::new();
    let fft = planner.plan_fft_forward(n);

    let mut buffer: Vec<Complex64> = signal.iter().map(|&x| Complex64::new(x, 0.0)).collect();
    fft.process(&mut buffer);

    // Find peak in positive frequencies (skip DC)
    let n_half = n / 2;
    let mut max_power = 0.0;
    let mut max_idx = 1;

    for (i, val) in buffer.iter().enumerate().take(n_half).skip(1) {
        let power = val.norm_sqr();
        if power > max_power {
            max_power = power;
            max_idx = i;
        }
    }

    // Convert index to frequency
    2.0 * PI * max_idx as f64 / (n as f64 * dt)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_oct_multiply_identity() {
        let one = [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        let e1 = [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        let result = oct_multiply(&one, &e1);
        assert!((result[1] - 1.0).abs() < 1e-10);
        assert!(result[0].abs() < 1e-10);
    }

    #[test]
    fn test_oct_multiply_e1_e2_e3() {
        // From Fano plane: e1 * e2 = e3
        let e1 = [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        let e2 = [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        let result = oct_multiply(&e1, &e2);
        assert!((result[3] - 1.0).abs() < 1e-10);
    }

    #[test]
    fn test_oct_multiply_anticommutative() {
        let e1 = [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        let e2 = [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        let ab = oct_multiply(&e1, &e2);
        let ba = oct_multiply(&e2, &e1);
        // ab = -ba for imaginary units
        for i in 0..8 {
            assert!((ab[i] + ba[i]).abs() < 1e-10, "ab[{0}] + ba[{0}] = {1}", i, ab[i] + ba[i]);
        }
    }

    #[test]
    fn test_oct_norm_composition() {
        // ||a*b|| = ||a|| * ||b|| (composition algebra)
        let a = [1.0, 2.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0];
        let b = [0.0, 1.0, 1.0, 0.5, 0.0, 0.0, 0.0, 0.0];
        let ab = oct_multiply(&a, &b);
        let norm_a = oct_norm_sq(&a).sqrt();
        let norm_b = oct_norm_sq(&b).sqrt();
        let norm_ab = oct_norm_sq(&ab).sqrt();
        let expected = norm_a * norm_b;
        assert!((norm_ab - expected).abs() < 1e-10, "||ab|| = {} vs ||a||*||b|| = {}", norm_ab, expected);
    }

    #[test]
    fn test_conjugate() {
        let a = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];
        let conj = oct_conjugate(&a);
        assert!((conj[0] - 1.0).abs() < 1e-10);
        for i in 1..8 {
            assert!((conj[i] + a[i]).abs() < 1e-10);
        }
    }

    #[test]
    fn test_energy_conservation_free() {
        let params = FieldParams {
            n: 32,
            l: 2.0 * PI,
            mass: 1.0,
            coupling: 0.0,
            dt: 0.01,
        };
        let (phi0, pi0) = gaussian_wave_packet(&params);
        let result = evolve(&phi0, &pi0, &params, 100);

        let e0 = result.energies[0];
        let max_drift: f64 = result.energies.iter()
            .map(|&e| (e - e0).abs() / e0)
            .fold(0.0_f64, f64::max);

        assert!(max_drift < 0.01, "Energy drift = {}", max_drift);
    }

    #[test]
    fn test_noether_charges_conserved() {
        let params = FieldParams::default();
        let (phi0, pi0) = gaussian_wave_packet(&params);
        let result = evolve(&phi0, &pi0, &params, 100);

        for i in 0..7 {
            let drift = (result.charges_final[i] - result.charges_initial[i]).abs();
            let scale = result.charges_initial[i].abs().max(1e-10);
            assert!(drift / scale < 0.1, "Charge {} drift = {}", i, drift);
        }
    }

    #[test]
    fn test_dispersion_relation() {
        let params = FieldParams {
            n: 128,
            l: 2.0 * PI,
            mass: 1.0,
            coupling: 0.0,
            dt: 0.01,
        };
        let results = measure_dispersion(&params, 2);

        for r in &results {
            assert!(r.rel_error < 0.05, "Mode {} rel_error = {}", r.mode, r.rel_error);
        }
    }
}
