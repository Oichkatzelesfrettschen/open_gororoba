//! Kerr-Newman metric: rotating, electrically charged black hole.
//!
//! The Kerr-Newman solution is the unique axially symmetric, stationary
//! solution to the Einstein-Maxwell equations.  It describes a black hole
//! with mass M, spin parameter a = J/M, and electric charge Q.
//!
//! Metric in Boyer-Lindquist coordinates (c = G = 1):
//!   ds^2 = -(1 - (2Mr - Q^2)/Sigma) dt^2
//!        - (4Mra sin^2 theta / Sigma) dt dphi
//!        + (Sigma / Delta) dr^2
//!        + Sigma dtheta^2
//!        + (A sin^2 theta / Sigma) dphi^2
//!
//! where:
//!   Sigma = r^2 + a^2 cos^2 theta
//!   Delta = r^2 - 2Mr + a^2 + Q^2
//!   A = (r^2 + a^2)^2 - a^2 Delta sin^2 theta
//!
//! Physical constraint (sub-extremal): M^2 >= a^2 + Q^2
//!
//! Electromagnetic 4-potential:
//!   A_t = -Qr / Sigma
//!   A_phi = -Qra sin^2 theta / Sigma
//!   A_r = A_theta = 0
//!
//! References:
//!   - Newman et al. (1965): J. Math. Phys. 6, 918
//!   - Carter (1968): Phys. Rev. 174, 1559
//!   - Wald (1984): General Relativity, Chapter 6

// ============================================================================
// Metric helper functions
// ============================================================================

/// Sigma = r^2 + a^2 cos^2(theta).
///
/// Unchanged from Kerr -- the charge does not modify Sigma.
pub fn sigma(r: f64, theta: f64, a: f64) -> f64 {
    let cos_th = theta.cos();
    r * r + a * a * cos_th * cos_th
}

/// Delta = r^2 - 2Mr + a^2 + Q^2.
///
/// The +Q^2 term is the only difference from Kerr's Delta.
/// Delta has two roots (horizons) when M^2 >= a^2 + Q^2.
pub fn delta(r: f64, m: f64, a: f64, q: f64) -> f64 {
    r * r - 2.0 * m * r + a * a + q * q
}

/// A = (r^2 + a^2)^2 - a^2 Delta sin^2(theta).
///
/// This quantity appears in the g_{phi phi} metric component.
pub fn big_a(r: f64, theta: f64, m: f64, a: f64, q: f64) -> f64 {
    let r2_plus_a2 = r * r + a * a;
    let sin_th = theta.sin();
    let d = delta(r, m, a, q);
    r2_plus_a2 * r2_plus_a2 - a * a * d * sin_th * sin_th
}

// ============================================================================
// Horizon structure
// ============================================================================

/// Outer (event) horizon: r_+ = M + sqrt(M^2 - a^2 - Q^2).
///
/// Returns NaN if M^2 < a^2 + Q^2 (super-extremal / naked singularity).
pub fn outer_horizon(m: f64, a: f64, q: f64) -> f64 {
    m + (m * m - a * a - q * q).sqrt()
}

/// Inner (Cauchy) horizon: r_- = M - sqrt(M^2 - a^2 - Q^2).
///
/// The Cauchy horizon is unstable (mass inflation instability).
pub fn inner_horizon(m: f64, a: f64, q: f64) -> f64 {
    m - (m * m - a * a - q * q).sqrt()
}

// ============================================================================
// Electromagnetic 4-potential
// ============================================================================

/// Time component of electromagnetic 4-potential: A_t = -Qr / Sigma.
///
/// This generates the electric field of the charged black hole.
pub fn potential_t(r: f64, theta: f64, a: f64, q: f64) -> f64 {
    -q * r / sigma(r, theta, a)
}

/// Azimuthal component of electromagnetic 4-potential:
/// A_phi = -Qra sin^2(theta) / Sigma.
///
/// Non-zero only when both charge Q and spin a are non-zero
/// (the spinning charge drags the EM field).
pub fn potential_phi(r: f64, theta: f64, a: f64, q: f64) -> f64 {
    let sin_th = theta.sin();
    -q * r * a * sin_th * sin_th / sigma(r, theta, a)
}

// ============================================================================
// Electromagnetic field strength
// ============================================================================

/// Radial electric field component: E_r = dA_t/dr.
///
/// E_r = -Q (Sigma - 2r^2) / Sigma^2.
pub fn electric_field_r(r: f64, theta: f64, a: f64, q: f64) -> f64 {
    let sig = sigma(r, theta, a);
    -q * (sig - 2.0 * r * r) / (sig * sig)
}

/// Magnetic field component (simplified): B ~ Qa cos(theta) / Sigma^2.
///
/// This is the poloidal magnetic field component generated by the
/// spinning charge.  It vanishes in the equatorial plane (theta = pi/2)
/// and is maximal at the poles.
pub fn magnetic_field(r: f64, theta: f64, a: f64, q: f64) -> f64 {
    let sig = sigma(r, theta, a);
    q * a * theta.cos() / (sig * sig)
}

// ============================================================================
// Ergosphere
// ============================================================================

/// Outer ergosphere boundary:
/// r_ergo = M + sqrt(M^2 - a^2 cos^2(theta) - Q^2).
///
/// The ergosphere always extends beyond the horizon (except at poles
/// where it touches the horizon).  Charge Q shrinks the ergosphere.
pub fn ergosphere_radius(theta: f64, m: f64, a: f64, q: f64) -> f64 {
    let cos_th = theta.cos();
    m + (m * m - a * a * cos_th * cos_th - q * q).sqrt()
}

// ============================================================================
// Frame dragging
// ============================================================================

/// Frame dragging angular velocity: omega = -g_{t phi} / g_{phi phi} = 2Mar / A.
///
/// This is the angular velocity at which local inertial frames are dragged
/// by the rotating spacetime.  It approaches the horizon angular velocity
/// Omega_H = a / (r_+^2 + a^2) at the outer horizon.
pub fn frame_dragging_omega(r: f64, theta: f64, m: f64, a: f64, q: f64) -> f64 {
    let aa = big_a(r, theta, m, a, q);
    2.0 * m * r * a / aa
}

// ============================================================================
// ISCO (Innermost Stable Circular Orbit) -- approximate with charge correction
// ============================================================================

/// Prograde ISCO radius with first-order charge correction.
///
/// Uses the standard Kerr ISCO formula (Bardeen 1972) plus a leading-order
/// correction +Q^2/(2M^2).  Exact for Q=0 (Kerr limit), approximate for Q>0.
pub fn isco_prograde(m: f64, a: f64, q: f64) -> f64 {
    let a_over_m = a / m;
    let one_minus_a2 = 1.0 - a_over_m * a_over_m;
    let cbrt_f = one_minus_a2.cbrt();
    let cbrt_p = (1.0 + a_over_m).cbrt();
    let cbrt_m = (1.0 - a_over_m).cbrt();
    let z1 = 1.0 + cbrt_f * (cbrt_p + cbrt_m);
    let z2 = (3.0 * a_over_m * a_over_m + z1 * z1).sqrt();
    let sqrt_term = ((3.0 - z1) * (3.0 + z1 + 2.0 * z2)).sqrt();
    let correction = q * q / (2.0 * m * m);
    m * (3.0 + z2 - sqrt_term) + correction
}

/// Retrograde ISCO radius with first-order charge correction.
///
/// Same as prograde but with + instead of - in the sqrt_term.
pub fn isco_retrograde(m: f64, a: f64, q: f64) -> f64 {
    let a_over_m = a / m;
    let one_minus_a2 = 1.0 - a_over_m * a_over_m;
    let cbrt_f = one_minus_a2.cbrt();
    let cbrt_p = (1.0 + a_over_m).cbrt();
    let cbrt_m = (1.0 - a_over_m).cbrt();
    let z1 = 1.0 + cbrt_f * (cbrt_p + cbrt_m);
    let z2 = (3.0 * a_over_m * a_over_m + z1 * z1).sqrt();
    let sqrt_term = ((3.0 - z1) * (3.0 + z1 + 2.0 * z2)).sqrt();
    let correction = q * q / (2.0 * m * m);
    m * (3.0 + z2 + sqrt_term) + correction
}

// ============================================================================
// Metric components
// ============================================================================

/// g_tt = -(1 - (2Mr - Q^2) / Sigma).
pub fn g_tt(r: f64, theta: f64, m: f64, a: f64, q: f64) -> f64 {
    let sig = sigma(r, theta, a);
    -(1.0 - (2.0 * m * r - q * q) / sig)
}

/// g_rr = Sigma / Delta.
pub fn g_rr(r: f64, theta: f64, m: f64, a: f64, q: f64) -> f64 {
    sigma(r, theta, a) / delta(r, m, a, q)
}

/// g_{theta theta} = Sigma.
pub fn g_thth(r: f64, theta: f64, a: f64) -> f64 {
    sigma(r, theta, a)
}

/// g_{phi phi} = A sin^2(theta) / Sigma.
pub fn g_phph(r: f64, theta: f64, m: f64, a: f64, q: f64) -> f64 {
    let sig = sigma(r, theta, a);
    let aa = big_a(r, theta, m, a, q);
    let sin_th = theta.sin();
    aa * sin_th * sin_th / sig
}

/// g_{t phi} = -2Mar sin^2(theta) / Sigma (frame dragging term).
///
/// Identical to Kerr -- the charge does not modify the cross term.
pub fn g_tphi(r: f64, theta: f64, m: f64, a: f64) -> f64 {
    let sig = sigma(r, theta, a);
    let sin_th = theta.sin();
    -2.0 * m * r * a * sin_th * sin_th / sig
}

// ============================================================================
// Physical validity
// ============================================================================

/// Sub-extremal: M^2 > a^2 + Q^2 (two distinct horizons).
pub fn is_sub_extremal(m: f64, a: f64, q: f64) -> bool {
    m * m > a * a + q * q
}

/// Extremal: M^2 = a^2 + Q^2 (horizons coincide).
///
/// Uses a tolerance for floating-point comparison.
pub fn is_extremal(m: f64, a: f64, q: f64) -> bool {
    (m * m - a * a - q * q).abs() < 1e-12 * m * m
}

/// Super-extremal: M^2 < a^2 + Q^2 (naked singularity, unphysical).
pub fn is_super_extremal(m: f64, a: f64, q: f64) -> bool {
    m * m < a * a + q * q
}

/// Physical black hole: M > 0 and M^2 >= a^2 + Q^2.
pub fn is_physical(m: f64, a: f64, q: f64) -> bool {
    m > 0.0 && m * m >= a * a + q * q
}

/// Check if a point is outside the outer horizon.
pub fn is_outside_horizon(r: f64, m: f64, a: f64, q: f64) -> bool {
    r > outer_horizon(m, a, q)
}

/// Check if a point is in the ergosphere (outside horizon, inside ergosphere boundary).
pub fn is_in_ergosphere(r: f64, theta: f64, m: f64, a: f64, q: f64) -> bool {
    r > outer_horizon(m, a, q) && r < ergosphere_radius(theta, m, a, q)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::f64::consts::PI;

    // -- Kerr limit (Q=0) --

    #[test]
    fn test_reduces_to_kerr_horizon() {
        // Q=0: r_+ = M + sqrt(M^2 - a^2) = 1 + sqrt(1 - 0.5^2)
        let r_plus = outer_horizon(1.0, 0.5, 0.0);
        let expected = 1.0 + (1.0 - 0.25_f64).sqrt();
        assert!((r_plus - expected).abs() < 1e-14, "r_+ = {r_plus}");
    }

    #[test]
    fn test_reduces_to_schwarzschild() {
        // a=0, Q=0: r_+ = 2M
        let r_plus = outer_horizon(1.0, 0.0, 0.0);
        assert!((r_plus - 2.0).abs() < 1e-14);
    }

    // -- Horizon structure --

    #[test]
    fn test_horizons_coincide_extremal() {
        // Reissner-Nordstrom extremal: a=0, Q=M -> M^2 = Q^2 exactly
        // r_+ = r_- = M
        let m = 1.0;
        let a = 0.0;
        let q = 1.0;
        let r_plus = outer_horizon(m, a, q);
        let r_minus = inner_horizon(m, a, q);
        assert!((r_plus - m).abs() < 1e-10, "r_+ = {r_plus}");
        assert!((r_minus - m).abs() < 1e-10, "r_- = {r_minus}");
    }

    #[test]
    fn test_outer_greater_than_inner() {
        let r_plus = outer_horizon(1.0, 0.3, 0.4);
        let r_minus = inner_horizon(1.0, 0.3, 0.4);
        assert!(r_plus > r_minus);
    }

    #[test]
    fn test_charge_shrinks_horizon() {
        let r_kerr = outer_horizon(1.0, 0.5, 0.0);
        let r_kn = outer_horizon(1.0, 0.5, 0.3);
        assert!(r_kn < r_kerr, "charge should shrink horizon");
    }

    // -- Delta --

    #[test]
    fn test_delta_zero_at_horizons() {
        let m = 1.0;
        let a = 0.3;
        let q = 0.4;
        let r_plus = outer_horizon(m, a, q);
        let d = delta(r_plus, m, a, q);
        assert!(d.abs() < 1e-10, "Delta(r_+) = {d}");
    }

    #[test]
    fn test_delta_positive_outside() {
        let m = 1.0;
        let a = 0.3;
        let q = 0.4;
        let r = outer_horizon(m, a, q) + 1.0;
        assert!(delta(r, m, a, q) > 0.0);
    }

    // -- Electromagnetic field --

    #[test]
    fn test_potential_t_zero_charge() {
        assert_eq!(potential_t(10.0, PI / 4.0, 0.5, 0.0), 0.0);
    }

    #[test]
    fn test_potential_phi_zero_spin() {
        // A_phi = 0 when a = 0 (non-rotating charged BH = Reissner-Nordstrom)
        assert_eq!(potential_phi(10.0, PI / 4.0, 0.0, 0.5), 0.0);
    }

    #[test]
    fn test_electric_field_sign() {
        // For positive charge Q > 0, at large r, E_r should be positive (outward)
        // E_r = -Q(Sigma - 2r^2)/Sigma^2. At large r, Sigma ~ r^2,
        // so Sigma - 2r^2 ~ -r^2, E_r ~ -Q*(-r^2)/r^4 = Q/r^2 > 0
        let e_r = electric_field_r(100.0, PI / 2.0, 0.0, 1.0);
        assert!(e_r > 0.0, "E_r = {e_r}");
    }

    #[test]
    fn test_magnetic_field_zero_at_equator() {
        // B ~ cos(theta) -> zero at equator
        let b = magnetic_field(10.0, PI / 2.0, 0.5, 1.0);
        assert!(b.abs() < 1e-14, "B = {b}");
    }

    #[test]
    fn test_magnetic_field_zero_without_spin() {
        // B ~ a -> zero when a = 0
        let b = magnetic_field(10.0, PI / 4.0, 0.0, 1.0);
        assert!(b.abs() < 1e-14);
    }

    // -- Ergosphere --

    #[test]
    fn test_ergosphere_at_pole_equals_horizon() {
        let m = 1.0;
        let a = 0.5;
        let q = 0.3;
        let r_ergo_pole = ergosphere_radius(0.0, m, a, q);
        let r_horizon = outer_horizon(m, a, q);
        assert!(
            (r_ergo_pole - r_horizon).abs() < 1e-10,
            "ergosphere touches horizon at pole"
        );
    }

    #[test]
    fn test_ergosphere_exceeds_horizon_at_equator() {
        let m = 1.0;
        let a = 0.5;
        let q = 0.3;
        let r_ergo_eq = ergosphere_radius(PI / 2.0, m, a, q);
        let r_horizon = outer_horizon(m, a, q);
        assert!(
            r_ergo_eq > r_horizon,
            "ergosphere extends beyond horizon at equator"
        );
    }

    #[test]
    fn test_charge_shrinks_ergosphere() {
        let r_kerr = ergosphere_radius(PI / 2.0, 1.0, 0.5, 0.0);
        let r_kn = ergosphere_radius(PI / 2.0, 1.0, 0.5, 0.3);
        assert!(r_kn < r_kerr, "charge should shrink ergosphere");
    }

    // -- Metric components --

    #[test]
    fn test_g_tt_negative_at_infinity() {
        // At large r: g_tt -> -1 (flat spacetime)
        let g = g_tt(1e6, PI / 4.0, 1.0, 0.5, 0.3);
        assert!((g - (-1.0)).abs() < 1e-5, "g_tt = {g}");
    }

    #[test]
    fn test_g_rr_positive_outside() {
        let m = 1.0;
        let a = 0.3;
        let q = 0.4;
        let r = outer_horizon(m, a, q) + 0.5;
        let g = g_rr(r, PI / 4.0, m, a, q);
        assert!(g > 0.0, "g_rr = {g}");
    }

    #[test]
    fn test_g_phph_positive() {
        let g = g_phph(10.0, PI / 4.0, 1.0, 0.5, 0.3);
        assert!(g > 0.0);
    }

    // -- Frame dragging --

    #[test]
    fn test_frame_dragging_positive_for_prograde() {
        let omega = frame_dragging_omega(5.0, PI / 2.0, 1.0, 0.5, 0.3);
        assert!(omega > 0.0, "prograde spin should drag prograde");
    }

    #[test]
    fn test_frame_dragging_decreases_with_r() {
        let o1 = frame_dragging_omega(3.0, PI / 2.0, 1.0, 0.5, 0.3);
        let o2 = frame_dragging_omega(10.0, PI / 2.0, 1.0, 0.5, 0.3);
        assert!(o2 < o1, "frame dragging should weaken with distance");
    }

    // -- ISCO --

    #[test]
    fn test_isco_schwarzschild_limit() {
        // a=0, Q=0: ISCO = 6M
        let r = isco_prograde(1.0, 0.0, 0.0);
        assert!((r - 6.0).abs() < 0.01, "ISCO = {r}");
    }

    #[test]
    fn test_isco_charge_increases_isco() {
        // Charge correction +Q^2/(2M^2) > 0, so ISCO moves outward
        let r_kerr = isco_prograde(1.0, 0.5, 0.0);
        let r_kn = isco_prograde(1.0, 0.5, 0.3);
        assert!(r_kn > r_kerr, "charge should push ISCO outward");
    }

    #[test]
    fn test_isco_retrograde_greater_than_prograde() {
        let r_pro = isco_prograde(1.0, 0.5, 0.3);
        let r_ret = isco_retrograde(1.0, 0.5, 0.3);
        assert!(r_ret > r_pro);
    }

    // -- Validity checks --

    #[test]
    fn test_sub_extremal() {
        assert!(is_sub_extremal(1.0, 0.5, 0.3));
        assert!(!is_sub_extremal(1.0, 0.8, 0.8)); // 0.64+0.64 = 1.28 > 1
    }

    #[test]
    fn test_physical_black_hole() {
        assert!(is_physical(1.0, 0.5, 0.3));
        assert!(is_physical(1.0, 0.6, 0.8)); // extremal: 0.36+0.64=1.0
        assert!(!is_physical(1.0, 0.8, 0.8)); // super-extremal
        assert!(!is_physical(-1.0, 0.0, 0.0)); // negative mass
    }

    #[test]
    fn test_ergosphere_region() {
        let m = 1.0;
        let a = 0.9;
        let q = 0.1;
        let r_h = outer_horizon(m, a, q);
        let r_e = ergosphere_radius(PI / 2.0, m, a, q);
        let r_mid = (r_h + r_e) / 2.0;
        assert!(is_in_ergosphere(r_mid, PI / 2.0, m, a, q));
        assert!(!is_in_ergosphere(r_e + 0.1, PI / 2.0, m, a, q));
    }
}
