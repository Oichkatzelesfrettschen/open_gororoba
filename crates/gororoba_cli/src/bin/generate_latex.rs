//! Generate LaTeX appendices from the TOML registry.
//!
//! Reads `registry/claims.toml` and `registry/insights.toml` and generates:
//! - `docs/latex/claims_appendix.tex`: All claims as a LaTeX longtable
//! - `docs/latex/insights_appendix.tex`: All insights as LaTeX sections

use std::path::PathBuf;

use clap::Parser;

/// Generate LaTeX appendices from the TOML registry.
#[derive(Parser)]
#[command(name = "generate-latex")]
struct Args {
    /// Registry directory
    #[arg(long, default_value = "registry")]
    dir: PathBuf,

    /// Output directory for generated .tex files
    #[arg(long, default_value = "docs/latex")]
    output_dir: PathBuf,
}

#[derive(serde::Deserialize)]
struct ClaimsRegistry {
    claim: Vec<ClaimEntry>,
}

#[derive(serde::Deserialize)]
struct ClaimEntry {
    id: String,
    statement: String,
    status: String,
    where_stated: String,
    #[allow(dead_code)]
    last_verified: String,
    #[allow(dead_code)]
    what_would_verify_refute: String,
}

#[derive(serde::Deserialize)]
struct InsightsRegistry {
    insight: Vec<InsightEntry>,
}

#[derive(serde::Deserialize)]
struct InsightEntry {
    id: String,
    title: String,
    date: Option<String>,
    status: Option<String>,
    summary: String,
    claims: Vec<String>,
    #[allow(dead_code)]
    sprint: Option<u32>,
}

fn escape_latex(s: &str) -> String {
    s.replace('\\', r"\textbackslash{}")
        .replace('&', r"\&")
        .replace('%', r"\%")
        .replace('$', r"\$")
        .replace('#', r"\#")
        .replace('_', r"\_")
        .replace('{', r"\{")
        .replace('}', r"\}")
        .replace('~', r"\textasciitilde{}")
        .replace('^', r"\textasciicircum{}")
}

fn truncate_for_table(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        escape_latex(s)
    } else {
        let truncated = &s[..max_len.min(s.len())];
        // Find last space to avoid cutting mid-word
        let cut = truncated.rfind(' ').unwrap_or(max_len);
        format!("{}...", escape_latex(&s[..cut]))
    }
}

fn generate_claims_appendix(claims: &[ClaimEntry]) -> String {
    let mut out = String::new();
    out.push_str("% Auto-generated by generate-latex from registry/claims.toml\n");
    out.push_str("% DO NOT EDIT -- regenerate with: cargo run --release --bin generate-latex\n\n");
    out.push_str("\\section{Claims Evidence Matrix}\\label{sec:claims-appendix}\n\n");
    out.push_str("\\begin{longtable}{|l|p{8cm}|l|l|}\n");
    out.push_str("\\hline\n");
    out.push_str("\\textbf{ID} & \\textbf{Statement} & \\textbf{Status} & \\textbf{Source} \\\\\n");
    out.push_str("\\hline\n");
    out.push_str("\\endfirsthead\n");
    out.push_str("\\hline\n");
    out.push_str("\\textbf{ID} & \\textbf{Statement} & \\textbf{Status} & \\textbf{Source} \\\\\n");
    out.push_str("\\hline\n");
    out.push_str("\\endhead\n");

    for claim in claims {
        out.push_str(&format!(
            "{} & {} & {} & {} \\\\\n\\hline\n",
            escape_latex(&claim.id),
            truncate_for_table(&claim.statement, 120),
            escape_latex(&claim.status),
            truncate_for_table(&claim.where_stated, 40),
        ));
    }

    out.push_str("\\end{longtable}\n");
    out
}

fn generate_insights_appendix(insights: &[InsightEntry]) -> String {
    let mut out = String::new();
    out.push_str("% Auto-generated by generate-latex from registry/insights.toml\n");
    out.push_str("% DO NOT EDIT -- regenerate with: cargo run --release --bin generate-latex\n\n");
    out.push_str("\\section{Research Insights}\\label{sec:insights-appendix}\n\n");

    for insight in insights {
        let status = insight.status.as_deref().unwrap_or("open");
        let date = insight.date.as_deref().unwrap_or("unknown");
        let claims_str = if insight.claims.is_empty() {
            "none".to_string()
        } else {
            insight.claims.join(", ")
        };

        out.push_str(&format!(
            "\\subsection{{{}: {}}}\\label{{sec:{}}}\n\n",
            escape_latex(&insight.id),
            escape_latex(&insight.title),
            insight.id.to_lowercase().replace('-', ""),
        ));
        out.push_str(&format!(
            "\\textbf{{Date:}} {} \\quad \\textbf{{Status:}} {} \\quad \\textbf{{Claims:}} {}\n\n",
            escape_latex(date),
            escape_latex(status),
            escape_latex(&claims_str),
        ));
        out.push_str(&format!("{}\n\n", escape_latex(&insight.summary)));
    }

    out
}

fn main() {
    let args = Args::parse();

    std::fs::create_dir_all(&args.output_dir).ok();

    // --- Claims ---
    let claims_path = args.dir.join("claims.toml");
    if claims_path.exists() {
        let content = std::fs::read_to_string(&claims_path).unwrap();
        let registry: ClaimsRegistry = toml::from_str(&content).unwrap();
        let tex = generate_claims_appendix(&registry.claim);
        let out_path = args.output_dir.join("claims_appendix.tex");
        std::fs::write(&out_path, &tex).unwrap();
        println!("Wrote {} claims to {}", registry.claim.len(), out_path.display());
    } else {
        eprintln!("WARNING: {} not found, skipping claims appendix", claims_path.display());
    }

    // --- Insights ---
    let insights_path = args.dir.join("insights.toml");
    if insights_path.exists() {
        let content = std::fs::read_to_string(&insights_path).unwrap();
        let registry: InsightsRegistry = toml::from_str(&content).unwrap();
        let tex = generate_insights_appendix(&registry.insight);
        let out_path = args.output_dir.join("insights_appendix.tex");
        std::fs::write(&out_path, &tex).unwrap();
        println!("Wrote {} insights to {}", registry.insight.len(), out_path.display());
    } else {
        eprintln!("WARNING: {} not found, skipping insights appendix", insights_path.display());
    }
}
