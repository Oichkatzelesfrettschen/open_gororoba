//! Generate LaTeX appendices from the TOML registry.
//!
//! Reads `registry/claims.toml`, `registry/insights.toml`, and
//! `registry/experiments.toml` and generates:
//! - `docs/latex/claims_appendix.tex`: All claims as a LaTeX longtable
//! - `docs/latex/insights_appendix.tex`: All insights as LaTeX sections
//! - `docs/latex/experiments_appendix.tex`: All experiments as a LaTeX longtable

use std::path::PathBuf;

use clap::Parser;

/// Generate LaTeX appendices from the TOML registry.
#[derive(Parser)]
#[command(name = "generate-latex")]
struct Args {
    /// Registry directory
    #[arg(long, default_value = "registry")]
    dir: PathBuf,

    /// Output directory for generated .tex files
    #[arg(long, default_value = "docs/latex")]
    output_dir: PathBuf,
}

#[derive(serde::Deserialize)]
struct ClaimsRegistry {
    claim: Vec<ClaimEntry>,
}

#[derive(serde::Deserialize)]
struct ClaimEntry {
    id: String,
    #[serde(default)]
    statement: Option<String>,
    #[serde(default)]
    status: Option<String>,
    #[serde(default)]
    where_stated: Option<String>,
    #[serde(default)]
    confidence: Option<String>,
    #[allow(dead_code)]
    #[serde(default)]
    phase: Option<String>,
    #[allow(dead_code)]
    #[serde(default)]
    last_verified: Option<String>,
    #[allow(dead_code)]
    #[serde(default)]
    what_would_verify_refute: Option<String>,
    #[allow(dead_code)]
    #[serde(default)]
    supporting_evidence: Option<Vec<String>>,
    #[allow(dead_code)]
    #[serde(default)]
    verification_method: Option<String>,
    #[allow(dead_code)]
    #[serde(default)]
    description: Option<String>,
    #[allow(dead_code)]
    #[serde(default)]
    sprint: Option<u32>,
    #[allow(dead_code)]
    #[serde(default)]
    dependencies: Option<Vec<String>>,
    #[allow(dead_code)]
    #[serde(default)]
    claims: Option<Vec<String>>,
    #[allow(dead_code)]
    #[serde(default)]
    insights: Option<Vec<String>>,
    #[allow(dead_code)]
    #[serde(default)]
    status_note: Option<String>,
}

#[derive(serde::Deserialize)]
struct ExperimentsRegistry {
    experiment: Vec<ExperimentEntry>,
}

#[derive(serde::Deserialize)]
struct ExperimentEntry {
    id: String,
    title: String,
    #[serde(default)]
    binary: Option<String>,
    method: String,
    #[serde(default)]
    run: Option<String>,
    #[serde(default)]
    deterministic: Option<bool>,
    #[serde(default)]
    gpu: Option<bool>,
    #[serde(default)]
    status: Option<String>,
    #[serde(default)]
    claims: Option<Vec<String>>,
}

#[derive(serde::Deserialize)]
struct InsightsRegistry {
    insight: Vec<InsightEntry>,
}

#[derive(serde::Deserialize)]
struct InsightEntry {
    id: String,
    #[serde(default)]
    title: Option<String>,
    #[serde(default)]
    date: Option<String>,
    #[serde(default)]
    status: Option<String>,
    #[serde(default)]
    summary: Option<String>,
    /// Newer insights use `insight` instead of `summary`.
    #[serde(default)]
    insight: Option<String>,
    #[serde(default)]
    claims: Vec<String>,
    #[allow(dead_code)]
    #[serde(default)]
    sprint: Option<u32>,
    #[allow(dead_code)]
    #[serde(default)]
    supporting_evidence: Option<Vec<String>>,
    #[allow(dead_code)]
    #[serde(default)]
    related_claims: Option<Vec<String>>,
    #[allow(dead_code)]
    #[serde(default)]
    experimental_support: Option<Vec<String>>,
    #[allow(dead_code)]
    #[serde(default)]
    confidence: Option<String>,
    #[allow(dead_code)]
    #[serde(default)]
    verified_date: Option<String>,
    #[allow(dead_code)]
    #[serde(default)]
    phase: Option<String>,
}

impl InsightEntry {
    fn body(&self) -> &str {
        self.summary
            .as_deref()
            .or(self.insight.as_deref())
            .unwrap_or("(no summary)")
    }
}

fn escape_latex(s: &str) -> String {
    s.replace('\\', r"\textbackslash{}")
        .replace('&', r"\&")
        .replace('%', r"\%")
        .replace('$', r"\$")
        .replace('#', r"\#")
        .replace('_', r"\_")
        .replace('{', r"\{")
        .replace('}', r"\}")
        .replace('~', r"\textasciitilde{}")
        .replace('^', r"\textasciicircum{}")
}

fn truncate_for_table(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        escape_latex(s)
    } else {
        let truncated = &s[..max_len.min(s.len())];
        // Find last space to avoid cutting mid-word
        let cut = truncated.rfind(' ').unwrap_or(max_len);
        format!("{}...", escape_latex(&s[..cut]))
    }
}

fn generate_claims_appendix(claims: &[ClaimEntry]) -> String {
    let mut out = String::new();
    out.push_str("% Auto-generated by generate-latex from registry/claims.toml\n");
    out.push_str("% DO NOT EDIT -- regenerate with: cargo run --release --bin generate-latex\n\n");
    out.push_str("\\section{Claims Evidence Matrix}\\label{sec:claims-appendix}\n\n");
    out.push_str(&format!("Total claims: {}.  Statuses: ", claims.len()));
    // Count by status
    let mut status_counts: std::collections::BTreeMap<&str, usize> =
        std::collections::BTreeMap::new();
    for claim in claims {
        let status = claim.status.as_deref().unwrap_or("unknown");
        *status_counts.entry(status).or_insert(0) += 1;
    }
    let counts: Vec<String> = status_counts
        .iter()
        .map(|(s, n)| format!("{} ({})", escape_latex(s), n))
        .collect();
    out.push_str(&counts.join(", "));
    out.push_str(".\n\n");
    out.push_str("\\begin{longtable}{|l|p{7cm}|l|l|l|}\n");
    out.push_str("\\hline\n");
    out.push_str("\\textbf{ID} & \\textbf{Statement} & \\textbf{Status} & \\textbf{Conf.} & \\textbf{Source} \\\\\n");
    out.push_str("\\hline\n");
    out.push_str("\\endfirsthead\n");
    out.push_str("\\hline\n");
    out.push_str("\\textbf{ID} & \\textbf{Statement} & \\textbf{Status} & \\textbf{Conf.} & \\textbf{Source} \\\\\n");
    out.push_str("\\hline\n");
    out.push_str("\\endhead\n");

    for claim in claims {
        let stmt = claim.statement.as_deref().unwrap_or("(no statement)");
        let status = claim.status.as_deref().unwrap_or("--");
        let conf = claim.confidence.as_deref().unwrap_or("--");
        let source = claim.where_stated.as_deref().unwrap_or("--");
        out.push_str(&format!(
            "{} & {} & {} & {} & {} \\\\\n\\hline\n",
            escape_latex(&claim.id),
            truncate_for_table(stmt, 100),
            escape_latex(status),
            escape_latex(conf),
            truncate_for_table(source, 35),
        ));
    }

    out.push_str("\\end{longtable}\n");
    out
}

fn generate_experiments_appendix(experiments: &[ExperimentEntry]) -> String {
    let mut out = String::new();
    out.push_str("% Auto-generated by generate-latex from registry/experiments.toml\n");
    out.push_str("% DO NOT EDIT -- regenerate with: cargo run --release --bin generate-latex\n\n");
    out.push_str("\\section{Experiments Portfolio}\\label{sec:experiments-appendix}\n\n");
    out.push_str(&format!(
        "Total experiments: {}.\\\\[0.5em]\n\n",
        experiments.len()
    ));

    for exp in experiments {
        let status = exp.status.as_deref().unwrap_or("unknown");
        let binary = exp.binary.as_deref().unwrap_or("--");
        let det = if exp.deterministic.unwrap_or(false) {
            "yes"
        } else {
            "no"
        };
        let gpu_flag = if exp.gpu.unwrap_or(false) {
            "yes"
        } else {
            "no"
        };
        let claims_str = match &exp.claims {
            Some(c) if !c.is_empty() => c.join(", "),
            _ => "none".to_string(),
        };

        out.push_str(&format!(
            "\\subsection{{{}: {}}}\\label{{sec:{}}}\n\n",
            escape_latex(&exp.id),
            escape_latex(&exp.title),
            exp.id.to_lowercase().replace('-', ""),
        ));
        out.push_str(&format!(
            "\\textbf{{Binary:}} \\texttt{{{}}} \\quad \
             \\textbf{{Status:}} {} \\quad \
             \\textbf{{Deterministic:}} {} \\quad \
             \\textbf{{GPU:}} {}\n\n",
            escape_latex(binary),
            escape_latex(status),
            det,
            gpu_flag,
        ));
        out.push_str(&format!(
            "\\textbf{{Method:}} {}\n\n",
            escape_latex(&exp.method)
        ));
        if let Some(run) = &exp.run {
            out.push_str(&format!(
                "\\textbf{{Run:}} \\texttt{{{}}}\n\n",
                escape_latex(run)
            ));
        }
        out.push_str(&format!(
            "\\textbf{{Claims:}} {}\n\n",
            escape_latex(&claims_str)
        ));
    }

    out
}

fn generate_insights_appendix(insights: &[InsightEntry]) -> String {
    let mut out = String::new();
    out.push_str("% Auto-generated by generate-latex from registry/insights.toml\n");
    out.push_str("% DO NOT EDIT -- regenerate with: cargo run --release --bin generate-latex\n\n");
    out.push_str("\\section{Research Insights}\\label{sec:insights-appendix}\n\n");

    for insight in insights {
        let status = insight.status.as_deref().unwrap_or("open");
        let date = insight.date.as_deref().unwrap_or("unknown");
        let claims_str = if insight.claims.is_empty() {
            "none".to_string()
        } else {
            insight.claims.join(", ")
        };

        let title = insight.title.as_deref().unwrap_or("(untitled)");
        out.push_str(&format!(
            "\\subsection{{{}: {}}}\\label{{sec:{}}}\n\n",
            escape_latex(&insight.id),
            escape_latex(title),
            insight.id.to_lowercase().replace('-', ""),
        ));
        out.push_str(&format!(
            "\\textbf{{Date:}} {} \\quad \\textbf{{Status:}} {} \\quad \\textbf{{Claims:}} {}\n\n",
            escape_latex(date),
            escape_latex(status),
            escape_latex(&claims_str),
        ));
        out.push_str(&format!("{}\n\n", escape_latex(insight.body())));
    }

    out
}

fn main() {
    let args = Args::parse();

    std::fs::create_dir_all(&args.output_dir).ok();

    // --- Claims ---
    let claims_path = args.dir.join("claims.toml");
    if claims_path.exists() {
        let content = std::fs::read_to_string(&claims_path).unwrap();
        let registry: ClaimsRegistry = toml::from_str(&content).unwrap();
        let tex = generate_claims_appendix(&registry.claim);
        let out_path = args.output_dir.join("claims_appendix.tex");
        std::fs::write(&out_path, &tex).unwrap();
        println!(
            "Wrote {} claims to {}",
            registry.claim.len(),
            out_path.display()
        );
    } else {
        eprintln!(
            "WARNING: {} not found, skipping claims appendix",
            claims_path.display()
        );
    }

    // --- Insights ---
    let insights_path = args.dir.join("insights.toml");
    if insights_path.exists() {
        let content = std::fs::read_to_string(&insights_path).unwrap();
        let registry: InsightsRegistry = toml::from_str(&content).unwrap();
        let tex = generate_insights_appendix(&registry.insight);
        let out_path = args.output_dir.join("insights_appendix.tex");
        std::fs::write(&out_path, &tex).unwrap();
        println!(
            "Wrote {} insights to {}",
            registry.insight.len(),
            out_path.display()
        );
    } else {
        eprintln!(
            "WARNING: {} not found, skipping insights appendix",
            insights_path.display()
        );
    }

    // --- Experiments ---
    let experiments_path = args.dir.join("experiments.toml");
    if experiments_path.exists() {
        let content = std::fs::read_to_string(&experiments_path).unwrap();
        let registry: ExperimentsRegistry = toml::from_str(&content).unwrap();
        let tex = generate_experiments_appendix(&registry.experiment);
        let out_path = args.output_dir.join("experiments_appendix.tex");
        std::fs::write(&out_path, &tex).unwrap();
        println!(
            "Wrote {} experiments to {}",
            registry.experiment.len(),
            out_path.display()
        );
    } else {
        eprintln!(
            "WARNING: {} not found, skipping experiments appendix",
            experiments_path.display()
        );
    }
}
