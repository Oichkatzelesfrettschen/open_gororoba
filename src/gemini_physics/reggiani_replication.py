from __future__ import annotations

from dataclasses import dataclass

import numpy as np

from gemini_physics.de_marrais_boxkites import diagonal_zero_products, primitive_assessors
from gemini_physics.optimized_algebra import cd_multiply_jit
from gemini_physics.sedenion_annihilator import (
    annihilator_info,
    is_reggiani_zd,
    left_multiplication_matrix,
    nullspace_basis,
    right_multiplication_matrix,
)


@dataclass(frozen=True)
class StandardZeroDivisor:
    assessor_low: int
    assessor_high: int
    diagonal_sign: int  # +1 for (e_low + e_high), -1 for (e_low - e_high)
    vector: np.ndarray


def standard_zero_divisors(*, atol: float = 1e-12) -> list[StandardZeroDivisor]:
    """
    Reggiani's "84 standard zero divisors" (Appendix/Table 1).

    In this repo, we model them as the two diagonals for each of de Marrais' 42 primitive assessors:
      (e_low +/- e_high), with (low,high) a primitive cross-assessor.

    These vectors have squared Euclidean norm 2 (so ||v|| = sqrt2). Under our annihilator check,
    each has a non-trivial left and right annihilator and is in ZD(S) per Reggiani's normalization.
    """
    out: list[StandardZeroDivisor] = []
    for low, high in primitive_assessors(atol=atol):
        for sign in (1, -1):
            v = np.zeros(16)
            v[low] = 1.0
            v[high] = float(sign)
            out.append(
                StandardZeroDivisor(
                    assessor_low=low,
                    assessor_high=high,
                    diagonal_sign=sign,
                    vector=v,
                )
            )
    return out


def standard_zero_divisor_partners(
    zd: StandardZeroDivisor, *, atol: float = 1e-12
) -> list[StandardZeroDivisor]:
    """
    Return the list of "standard" zero divisors v such that:

        zd.vector * v.vector == 0

    restricted to the diagonal-form family generated by the 42 primitive assessors.

    Empirically (and consistently with Reggiani's Table 1 format), each standard diagonal-form
    zero divisor has exactly 4 such standard annihilating partners; these 4 vectors span its
    (4-dimensional) annihilator subspace.
    """
    a = (zd.assessor_low, zd.assessor_high)
    s = float(zd.diagonal_sign)

    all_zds = standard_zero_divisors(atol=atol)
    partners: list[StandardZeroDivisor] = []
    for cand in all_zds:
        if (
            cand.assessor_low == zd.assessor_low
            and cand.assessor_high == zd.assessor_high
            and cand.diagonal_sign == zd.diagonal_sign
        ):
            continue
        b = (cand.assessor_low, cand.assessor_high)
        t = float(cand.diagonal_sign)
        if (s, t) in diagonal_zero_products(a, b, atol=atol):
            partners.append(cand)

    if len(partners) != 4:
        key = (zd.assessor_low, zd.assessor_high, zd.diagonal_sign)
        raise ValueError(
            f"Expected exactly 4 standard partners for {key}, got {len(partners)}"
        )
    return sorted(
        partners, key=lambda p: (p.assessor_low, p.assessor_high, p.diagonal_sign)
    )


def assert_standard_zero_divisor_annihilators(
    zd: StandardZeroDivisor, *, atol: float = 1e-12
) -> None:
    """
    Sanity-check a standard zero divisor against the repo's definition of ZD(S):
    - squared norm is 2
    - has non-trivial left and right annihilator
    - every computed annihilator basis vector actually annihilates (within tolerance)
    """
    v = np.asarray(zd.vector, dtype=float)
    if not np.isclose(float(np.dot(v, v)), 2.0, atol=atol, rtol=0.0):
        raise AssertionError("Expected standard zero divisor to have squared norm 2.")
    if not is_reggiani_zd(v, atol=atol):
        raise AssertionError("Expected standard zero divisor to be in Reggiani ZD(S).")

    info = annihilator_info(v, atol=atol)
    if info.left_nullity <= 0 or info.right_nullity <= 0:
        raise AssertionError(f"Expected non-trivial annihilators, got {info}.")

    # Basis check: each nullspace basis vector should annihilate.
    la = left_multiplication_matrix(v)
    ra = right_multiplication_matrix(v)
    left_basis = nullspace_basis(la, atol=atol)
    right_basis = nullspace_basis(ra, atol=atol)

    for i in range(left_basis.shape[1]):
        b = left_basis[:, i]
        prod = cd_multiply_jit(v, b, 16)
        if not np.allclose(prod, 0.0, atol=1e-10, rtol=0.0):
            raise AssertionError("Left annihilator basis check failed.")

    for i in range(right_basis.shape[1]):
        b = right_basis[:, i]
        prod = cd_multiply_jit(b, v, 16)
        if not np.allclose(prod, 0.0, atol=1e-10, rtol=0.0):
            raise AssertionError("Right annihilator basis check failed.")

    partners = standard_zero_divisor_partners(zd, atol=atol)
    partner_matrix = np.stack([p.vector for p in partners], axis=1)  # 16x4

    left_coords = left_basis.T @ partner_matrix
    if np.linalg.matrix_rank(left_coords, tol=1e-8) != 4:
        raise AssertionError("Expected standard partners to span the left annihilator subspace.")
