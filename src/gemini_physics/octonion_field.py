"""
Octonion-valued scalar field Hamiltonian on a 1D periodic lattice.

Restricts to the octonionic subalgebra of the Cayley-Dickson tower to
bypass the sedenion non-associativity obstruction (C-030).  Octonions
are alternative: every subalgebra generated by two elements is
associative, guaranteeing consistent Lagrangians for power-type
potentials via explicit parenthesization.

Lagrangian density (1+1D, M=1):
  L = (1/2)||dphi/dt||^2 - (1/2)||dphi/dx||^2 - (1/2)m^2||phi||^2
      - (lambda/4)||phi||^4

Euler-Lagrange EOM:
  d^2 phi/dt^2 = Lap(phi) - m^2*phi - lambda*||phi||^2*phi

Hamiltonian (Legendre transform, pi = dphi/dt):
  H = (1/2)||pi||^2 + (1/2)||grad phi||^2 + (1/2)m^2||phi||^2
      + (lambda/4)||phi||^4

Note: For a single octonion field with quartic ||phi||^4 interaction,
the composition algebra property ||a*b|| = ||a||*||b|| implies
||phi*phi||^2 = ||phi||^4.  The octonionic product structure becomes
visible only in multi-field interactions or cubic couplings with
explicit parenthesization.

Symplectic integrator: Stormer-Verlet (second-order, time-reversible).

Noether charges from octonionic U(1) rotations phi -> phi + eps*(e_k*phi):
  Q_k = sum_i pi_i . (e_k * phi_i)

Refs:
  Dixon, G.M. (1994), "Division Algebras: Octonions, Quaternions,
    Complex Numbers and the Algebraic Design of Physics."
  Tze, C.H. & Nam, S. (1989), Ann. Phys. 193, 419.
"""
from __future__ import annotations

import numpy as np

# -- Octonion structure constants from the Fano plane --
# Oriented triples (i,j,k): e_i * e_j = +e_k (cyclic).
_FANO_TRIPLES = [
    (1, 2, 3), (1, 4, 5), (1, 7, 6),
    (2, 4, 6), (2, 5, 7), (3, 4, 7), (3, 6, 5),
]

# _SC[(i,j)] = (sign, k) for e_i * e_j = sign * e_k, with i,j >= 1.
_SC: dict[tuple[int, int], tuple[int, int]] = {}
for _p, _q, _r in _FANO_TRIPLES:
    _SC[(_p, _q)] = (+1, _r)
    _SC[(_q, _r)] = (+1, _p)
    _SC[(_r, _p)] = (+1, _q)
    _SC[(_q, _p)] = (-1, _r)
    _SC[(_r, _q)] = (-1, _p)
    _SC[(_p, _r)] = (-1, _q)


# -- Algebra operations (vectorized over spatial lattice) --

def oct_multiply_field(phi, psi):
    """
    Pointwise octonion product of two fields.

    Parameters
    ----------
    phi, psi : ndarray, shape (N, 8)

    Returns
    -------
    ndarray, shape (N, 8)
    """
    out = np.zeros_like(phi)
    # Real part: a0*b0 - sum_{i>0} a_i*b_i.
    out[:, 0] = phi[:, 0] * psi[:, 0] - np.sum(
        phi[:, 1:] * psi[:, 1:], axis=1,
    )
    # e0*e_i and e_i*e0 contributions.
    for a in range(1, 8):
        out[:, a] = phi[:, 0] * psi[:, a] + phi[:, a] * psi[:, 0]
    # Cross terms from Fano-plane structure constants.
    for (i, j), (s, k) in _SC.items():
        out[:, k] += s * phi[:, i] * psi[:, j]
    return out


def oct_multiply(a, b):
    """Multiply two single octonions a, b of shape (8,)."""
    return oct_multiply_field(a[np.newaxis], b[np.newaxis])[0]


def oct_conjugate_field(phi):
    """Conjugate: negate imaginary parts. (N, 8) -> (N, 8)."""
    out = phi.copy()
    out[:, 1:] *= -1
    return out


# -- Hamiltonian and force --

def hamiltonian(phi, pi, dx, mass, coupling=0.0):
    """
    Discrete Hamiltonian (per-site sum, no explicit dx prefactor).

    H = (1/2) sum ||pi_i||^2
      + (1/(2*dx^2)) sum ||phi_{i+1} - phi_i||^2
      + (m^2/2) sum ||phi_i||^2
      + (lambda/4) sum ||phi_i||^4
    """
    T = 0.5 * np.sum(pi ** 2)
    dphi = np.roll(phi, -1, axis=0) - phi
    V_grad = 0.5 * np.sum(dphi ** 2) / dx ** 2
    V_mass = 0.5 * mass ** 2 * np.sum(phi ** 2)
    V_int = 0.0
    if coupling != 0.0:
        norm_sq = np.sum(phi ** 2, axis=1)
        V_int = 0.25 * coupling * np.sum(norm_sq ** 2)
    return T + V_grad + V_mass + V_int


def force(phi, dx, mass, coupling=0.0):
    """
    Force f_i = -dV/dphi_i at each lattice site.

    Free field: f = Lap(phi) - m^2 * phi.
    Quartic:    f -= lambda * ||phi||^2 * phi.
    """
    lap = (
        np.roll(phi, -1, axis=0) + np.roll(phi, 1, axis=0) - 2.0 * phi
    ) / dx ** 2
    f = lap - mass ** 2 * phi
    if coupling != 0.0:
        norm_sq = np.sum(phi ** 2, axis=1, keepdims=True)
        f -= coupling * norm_sq * phi
    return f


# -- Symplectic integrator --

def stormer_verlet_step(phi, pi, dt, dx, mass, coupling=0.0):
    """One Stormer-Verlet (leapfrog) step, second-order symplectic."""
    pi_half = pi + 0.5 * dt * force(phi, dx, mass, coupling)
    phi_new = phi + dt * pi_half
    pi_new = pi_half + 0.5 * dt * force(phi_new, dx, mass, coupling)
    return phi_new, pi_new


def evolve(phi0, pi0, dt, n_steps, dx, mass, coupling=0.0):
    """
    Evolve the field for n_steps and return (phi, pi, energies).

    energies[i] is the Hamiltonian evaluated after step i (energies[0]
    is the initial energy).
    """
    phi = phi0.copy()
    pi = pi0.copy()
    energies = np.empty(n_steps + 1)
    energies[0] = hamiltonian(phi, pi, dx, mass, coupling)
    for step in range(n_steps):
        phi, pi = stormer_verlet_step(phi, pi, dt, dx, mass, coupling)
        energies[step + 1] = hamiltonian(phi, pi, dx, mass, coupling)
    return phi, pi, energies


# -- Noether charges --

def noether_charges(phi, pi, dx):
    """
    Seven conserved U(1) charges from octonionic phase rotations.

    Q_k = sum_i pi_i . (e_k * phi_i)  for k = 1..7.

    These generate rotations phi -> phi + eps*(e_k * phi).  For the free
    theory they span a Cartan subalgebra of SO(8); under octonionic
    interactions only the G2 automorphism subgroup survives.
    """
    N = phi.shape[0]
    charges = np.zeros(7)
    e_k = np.zeros((N, 8))
    for k in range(1, 8):
        e_k[:] = 0.0
        e_k[:, k] = 1.0
        rotated = oct_multiply_field(e_k, phi)
        charges[k - 1] = np.sum(pi * rotated)
    return charges


# -- Diagnostics --

def measure_dispersion(mass, N=128, L=2.0 * np.pi, n_modes=3):
    """
    Measure free-field dispersion relation by FFT of standing waves.

    Returns list of dicts with mode, k, omega_exact, omega_measured, rel_err.
    """
    dx = L / N
    x = np.linspace(0.0, L, N, endpoint=False)
    results = []

    for mode_n in range(1, n_modes + 1):
        k = 2.0 * np.pi * mode_n / L
        omega_exact = np.sqrt(k ** 2 + mass ** 2)
        T_period = 2.0 * np.pi / omega_exact
        dt = T_period / 200
        n_steps = int(4 * T_period / dt)

        # Standing wave in e_1 direction.
        phi0 = np.zeros((N, 8))
        phi0[:, 1] = 0.1 * np.sin(k * x)
        pi0 = np.zeros((N, 8))

        # Probe index where sin(k*x) is large.
        idx = max(N // (4 * mode_n), 1)

        # Evolve and record amplitude at probe point.
        amp = np.empty(n_steps + 1)
        phi = phi0.copy()
        pi = pi0.copy()
        amp[0] = phi[idx, 1]
        for s in range(n_steps):
            phi, pi = stormer_verlet_step(phi, pi, dt, dx, mass)
            amp[s + 1] = phi[idx, 1]

        # Peak frequency from FFT.
        fft_v = np.fft.rfft(amp)
        freqs = np.fft.rfftfreq(len(amp), d=dt)
        power = np.abs(fft_v[1:]) ** 2
        peak = np.argmax(power) + 1
        omega_measured = 2.0 * np.pi * freqs[peak]

        rel_err = abs(omega_measured - omega_exact) / omega_exact
        results.append({
            "mode": mode_n,
            "k": k,
            "omega_exact": omega_exact,
            "omega_measured": omega_measured,
            "rel_err": rel_err,
        })

    return results


def run_field_analysis(N=64, L=2.0 * np.pi, mass=1.0, coupling=0.0,
                       dt=0.01, n_steps=1000, seed=42):
    """
    Run a complete simulation and return results dict.

    Generates a Gaussian wave packet initial condition, evolves it,
    and reports energy conservation and Noether charge drift.
    """
    dx = L / N
    x = np.linspace(0.0, L, N, endpoint=False)

    # Gaussian wave packet with octonionic phase structure.
    sigma = L / 8
    envelope = np.exp(-0.5 * ((x - L / 2) / sigma) ** 2)
    phi0 = np.zeros((N, 8))
    phi0[:, 0] = envelope * np.cos(4.0 * x)
    phi0[:, 1] = envelope * np.sin(4.0 * x)
    pi0 = np.zeros((N, 8))
    pi0[:, 0] = -0.5 * envelope * np.sin(4.0 * x)
    pi0[:, 1] = 0.5 * envelope * np.cos(4.0 * x)

    charges_0 = noether_charges(phi0, pi0, dx)
    phi, pi, energies = evolve(phi0, pi0, dt, n_steps, dx, mass, coupling)
    charges_f = noether_charges(phi, pi, dx)

    E0 = energies[0]
    max_energy_drift = float(np.max(np.abs(energies - E0)) / abs(E0))

    return {
        "energies": energies,
        "charges_initial": charges_0,
        "charges_final": charges_f,
        "max_energy_drift": max_energy_drift,
        "E0": E0,
    }
