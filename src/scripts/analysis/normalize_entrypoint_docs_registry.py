#!/usr/bin/env python3
"""
Bootstrap tracked entrypoint markdown files into TOML-first registry.

Inputs:
- AGENTS.md
- CLAUDE.md
- GEMINI.md
- README.md
- curated/README.md
- curated/01_theory_frameworks/README_COQ.md
- data/csv/README.md
- data/artifacts/README.md

Output:
- registry/entrypoint_docs.toml
"""

from __future__ import annotations

import argparse
from pathlib import Path

ENTRYPOINT_FILES = [
    "AGENTS.md",
    "CLAUDE.md",
    "GEMINI.md",
    "README.md",
    "curated/README.md",
    "curated/01_theory_frameworks/README_COQ.md",
    "data/csv/README.md",
    "data/artifacts/README.md",
]

HEADER_PREFIXES = (
    "<!-- AUTO-GENERATED:",
    "<!-- Source of truth:",
)


def _assert_ascii(text: str, context: str) -> None:
    bad = sorted({ch for ch in text if ord(ch) > 127})
    if bad:
        sample = "".join(bad[:20])
        raise SystemExit(f"ERROR: Non-ASCII output in {context}: {sample!r}")


def _esc(text: str) -> str:
    escaped = (
        text.replace("\\", "\\\\")
        .replace('"', '\\"')
        .replace("\n", "\\n")
        .replace("\r", "\\r")
        .replace("\t", "\\t")
    )
    return f'"{escaped}"'


def _to_multiline(content: str) -> str:
    out: list[str] = []
    for ch in content:
        code = ord(ch)
        if ch == "\\":
            out.append("\\\\")
        elif ch == '"':
            out.append('\\"')
        elif ch == "\t":
            out.append("\\t")
        elif ch == "\r":
            out.append("\\r")
        elif ch == "\n":
            out.append("\n")
        elif code < 32:
            out.append(f"\\u{code:04X}")
        else:
            out.append(ch)
    return '"""\n' + "".join(out).strip() + '\n"""'


def _strip_generated_header(text: str) -> str:
    lines = text.splitlines()
    i = 0
    while i < len(lines):
        stripped = lines[i].strip()
        if not stripped:
            i += 1
            continue
        if any(stripped.startswith(prefix) for prefix in HEADER_PREFIXES):
            i += 1
            continue
        break
    return "\n".join(lines[i:]).strip()


def _title_from_body(path: str, body: str) -> str:
    for line in body.splitlines():
        if line.startswith("# "):
            return line[2:].strip()
    return Path(path).stem


def _render(docs: list[tuple[str, str, str]]) -> str:
    lines: list[str] = []
    lines.append("# Entrypoint markdown registry (TOML-first).")
    lines.append("# Generated by src/scripts/analysis/normalize_entrypoint_docs_registry.py")
    lines.append("")
    lines.append("[entrypoint_docs]")
    lines.append("authoritative = true")
    lines.append('updated = "2026-02-09"')
    lines.append(f"document_count = {len(docs)}")
    lines.append("")
    for path, title, body in docs:
        lines.append("[[document]]")
        lines.append(f"path = {_esc(path)}")
        lines.append(f"title = {_esc(title)}")
        lines.append(f"body_markdown = {_to_multiline(body)}")
        lines.append("")
    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--repo-root",
        default=str(Path(__file__).resolve().parents[3]),
        help="Repository root.",
    )
    parser.add_argument(
        "--bootstrap-from-markdown",
        action="store_true",
        help="Required flag to ingest markdown into TOML registry.",
    )
    parser.add_argument(
        "--out",
        default="registry/entrypoint_docs.toml",
        help="Output TOML registry path.",
    )
    args = parser.parse_args()
    if not args.bootstrap_from_markdown:
        raise SystemExit("ERROR: pass --bootstrap-from-markdown to ingest markdown sources")

    root = Path(args.repo_root).resolve()
    docs: list[tuple[str, str, str]] = []
    for rel in ENTRYPOINT_FILES:
        src = root / rel
        if not src.exists():
            raise SystemExit(f"ERROR: missing entrypoint markdown: {rel}")
        body = _strip_generated_header(src.read_text(encoding="utf-8", errors="ignore"))
        title = _title_from_body(rel, body)
        docs.append((rel, title, body))

    rendered = _render(docs)
    out_path = root / args.out
    _assert_ascii(rendered, str(out_path))
    out_path.write_text(rendered, encoding="utf-8")
    print(f"Wrote {out_path} with {len(docs)} entrypoint docs.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
