#!/usr/bin/env python3
"""
Build holding registries for external/archive CSV backlog conversion.

Inputs:
- registry/csv_inventory.toml

Outputs:
- registry/external_csv_holding.toml
- registry/archive_csv_holding.toml
- registry/manifests/external_csv_holding_manifest.txt
- registry/manifests/archive_csv_holding_manifest.txt
"""

from __future__ import annotations

import argparse
import json
import tomllib
from pathlib import Path

UPDATED_STAMP = "2026-02-09"


def _assert_ascii(text: str, context: str) -> None:
    bad = sorted({ch for ch in text if ord(ch) > 127})
    if bad:
        sample = "".join(bad[:20])
        raise SystemExit(f"ERROR: Non-ASCII output in {context}: {sample!r}")


def _esc(value: str) -> str:
    return json.dumps(value, ensure_ascii=True)


def _render_registry(table_name: str, rows: list[dict[str, object]], lane_label: str) -> str:
    lines: list[str] = []
    lines.append(f"# Holding registry for {lane_label} CSV ingestion into TOML scrolls.")
    lines.append("# Generated by src/scripts/analysis/build_csv_holding_registries.py")
    lines.append("")
    lines.append(f"[{table_name}]")
    lines.append(f'updated = "{UPDATED_STAMP}"')
    lines.append("authoritative = true")
    lines.append('queue_status = "active"')
    lines.append(f"dataset_count = {len(rows)}")
    lines.append("")
    for row in rows:
        lines.append("[[dataset]]")
        lines.append(f"path = {_esc(str(row['path']))}")
        lines.append(f"source_sha256 = {_esc(str(row['source_sha256']))}")
        lines.append(f"size_bytes = {int(row['size_bytes'])}")
        lines.append(f"git_status = {_esc(str(row['git_status']))}")
        lines.append('hold_status = "queued_for_scroll_conversion"')
        lines.append(f"target_lane = {_esc(str(row['target_lane']))}")
        lines.append("")
    return "\n".join(lines)


def _write_manifest(path: Path, values: list[str]) -> None:
    payload = "\n".join(values) + ("\n" if values else "")
    _assert_ascii(payload, str(path))
    path.write_text(payload, encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--repo-root",
        default=str(Path(__file__).resolve().parents[3]),
        help="Repository root.",
    )
    parser.add_argument(
        "--inventory",
        default="registry/csv_inventory.toml",
        help="Input CSV inventory TOML path.",
    )
    parser.add_argument(
        "--external-out",
        default="registry/external_csv_holding.toml",
        help="Output external holding registry path.",
    )
    parser.add_argument(
        "--archive-out",
        default="registry/archive_csv_holding.toml",
        help="Output archive holding registry path.",
    )
    parser.add_argument(
        "--external-manifest",
        default="registry/manifests/external_csv_holding_manifest.txt",
        help="External holding source manifest path.",
    )
    parser.add_argument(
        "--archive-manifest",
        default="registry/manifests/archive_csv_holding_manifest.txt",
        help="Archive holding source manifest path.",
    )
    args = parser.parse_args()

    root = Path(args.repo_root).resolve()
    inventory = tomllib.loads((root / args.inventory).read_text(encoding="utf-8"))
    docs = inventory.get("document", [])

    external_rows: list[dict[str, object]] = []
    archive_rows: list[dict[str, object]] = []

    for row in sorted(docs, key=lambda item: str(item.get("path", ""))):
        zone = str(row.get("zone", ""))
        path = str(row.get("path", ""))
        payload = {
            "path": path,
            "source_sha256": str(row.get("sha256", "")),
            "size_bytes": int(row.get("size_bytes", 0)),
            "git_status": str(row.get("git_status", "")),
            "target_lane": "",
        }
        if zone == "external_csv":
            payload["target_lane"] = "external_csv_holding"
            external_rows.append(payload)
        elif zone == "archive_csv":
            payload["target_lane"] = "archive_csv_holding"
            archive_rows.append(payload)

    external_out = root / args.external_out
    archive_out = root / args.archive_out
    external_out.parent.mkdir(parents=True, exist_ok=True)
    archive_out.parent.mkdir(parents=True, exist_ok=True)

    external_rendered = _render_registry(
        "external_csv_holding",
        external_rows,
        lane_label="external",
    )
    archive_rendered = _render_registry(
        "archive_csv_holding",
        archive_rows,
        lane_label="archive",
    )

    _assert_ascii(external_rendered, str(external_out))
    _assert_ascii(archive_rendered, str(archive_out))
    external_out.write_text(external_rendered, encoding="utf-8")
    archive_out.write_text(archive_rendered, encoding="utf-8")

    external_manifest = root / args.external_manifest
    archive_manifest = root / args.archive_manifest
    external_manifest.parent.mkdir(parents=True, exist_ok=True)
    _write_manifest(external_manifest, [str(row["path"]) for row in external_rows])
    _write_manifest(archive_manifest, [str(row["path"]) for row in archive_rows])

    print(f"Wrote external holding registry: {external_out} ({len(external_rows)} records)")
    print(f"Wrote archive holding registry: {archive_out} ({len(archive_rows)} records)")
    print(f"Wrote external manifest: {external_manifest}")
    print(f"Wrote archive manifest: {archive_manifest}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
