#!/usr/bin/env python3
"""
Generate a deterministic plan for organizing data/artifacts without moving files.

This script is intentionally conservative:
- It does not modify data/artifacts/.
- It writes a human-facing report under reports/ only.
- It uses stable sorting and avoids timestamps to keep outputs reproducible.

The goal is to highlight:
- Which artifacts are tracked by data/artifacts/ARTIFACTS_MANIFEST.csv
- Which artifacts are "flat" under data/artifacts/ (historical layout)
- Candidate domain folders for flat, untracked files (heuristic by extension)
"""

from __future__ import annotations

import csv
from dataclasses import dataclass
from pathlib import Path


REPO_ROOT = Path(__file__).resolve().parents[3]
ARTIFACTS_ROOT = REPO_ROOT / "data" / "artifacts"
MANIFEST_PATH = ARTIFACTS_ROOT / "ARTIFACTS_MANIFEST.csv"
REPORT_PATH = REPO_ROOT / "reports" / "artifacts_reorg_plan.md"


@dataclass(frozen=True)
class CandidateMove:
    src_rel: str
    dst_rel: str
    reason: str


def _load_manifest_paths() -> set[str]:
    if not MANIFEST_PATH.exists():
        return set()
    with MANIFEST_PATH.open("r", encoding="utf-8", newline="") as f:
        reader = csv.DictReader(f)
        paths: set[str] = set()
        for row in reader:
            p = (row.get("artifact_path") or "").strip()
            if p:
                paths.add(p)
    return paths


def _guess_domain_for_extension(ext: str) -> str:
    ext = ext.lower().lstrip(".")
    if ext in {"png", "jpg", "jpeg", "webp", "gif", "svg"}:
        return "images"
    if ext in {"csv", "tsv"}:
        return "tables"
    if ext in {"json"}:
        return "json"
    if ext in {"md", "txt"}:
        return "notes"
    if ext in {"pdf"}:
        return "pdf"
    if ext in {"mp4", "mov", "mkv"}:
        return "video"
    return "misc"


def _iter_artifact_files() -> list[Path]:
    if not ARTIFACTS_ROOT.exists():
        return []
    return sorted([p for p in ARTIFACTS_ROOT.rglob("*") if p.is_file()])


def _is_metadata_file(p: Path) -> bool:
    if p.name in {"README.md", "ARTIFACTS_MANIFEST.csv", "PROVENANCE.local.json"}:
        return True
    return False


def _is_provenance_sidecar(p: Path) -> bool:
    return p.name.endswith(".PROVENANCE.json")


def _relative_repo_posix(p: Path) -> str:
    return p.relative_to(REPO_ROOT).as_posix()


def _relative_artifacts_posix(p: Path) -> str:
    return p.relative_to(ARTIFACTS_ROOT).as_posix()


def main() -> int:
    if not ARTIFACTS_ROOT.exists():
        print(f"ERROR: missing artifacts root: {ARTIFACTS_ROOT}")
        return 2

    manifest_paths = _load_manifest_paths()
    artifact_files = _iter_artifact_files()

    flat_files: list[Path] = []
    tracked_files: list[str] = []
    untracked_files: list[Path] = []
    orphaned_provenance: list[str] = []

    for p in artifact_files:
        if _is_metadata_file(p):
            continue
        if _is_provenance_sidecar(p):
            base = p.with_suffix("")  # remove .json
            # base is now "...<ext>.PROVENANCE"; remove that suffix too
            if base.name.endswith(".PROVENANCE"):
                artifact = base.with_suffix("")
                if not artifact.exists():
                    orphaned_provenance.append(_relative_repo_posix(p))
            continue
        rel_repo = _relative_repo_posix(p)
        rel_art = _relative_artifacts_posix(p)

        if rel_repo in manifest_paths:
            tracked_files.append(rel_repo)
        else:
            untracked_files.append(p)

        if p.parent == ARTIFACTS_ROOT:
            flat_files.append(p)

    candidates: list[CandidateMove] = []
    for p in sorted(flat_files):
        if _is_metadata_file(p) or _is_provenance_sidecar(p):
            continue
        rel_repo = _relative_repo_posix(p)
        if rel_repo in manifest_paths:
            continue
        ext = p.suffix
        domain = _guess_domain_for_extension(ext)
        dst = (ARTIFACTS_ROOT / domain / p.name)
        candidates.append(
            CandidateMove(
                src_rel=rel_repo,
                dst_rel=_relative_repo_posix(dst),
                reason=f"flat file under data/artifacts; ext={ext or '(none)'} -> domain={domain}",
            )
        )

    lines: list[str] = []
    lines.append("# Artifacts Reorganization Plan (Report Only)")
    lines.append("")
    lines.append("This report is generated by:")
    lines.append("")
    lines.append("- make artifacts-reorg-plan")
    lines.append("")
    lines.append("It proposes candidate moves but does not modify any files.")
    lines.append("")
    lines.append("## Summary")
    lines.append("")
    lines.append(f"- Artifacts root: `{ARTIFACTS_ROOT.relative_to(REPO_ROOT)}`")
    lines.append(f"- Manifest: `{MANIFEST_PATH.relative_to(REPO_ROOT)}`")
    lines.append(
        f"- Total files under data/artifacts (excluding metadata/sidecars): {len([p for p in artifact_files if (not _is_metadata_file(p)) and (not _is_provenance_sidecar(p))])}"
    )
    lines.append(f"- Manifest-tracked files present on disk: {len(tracked_files)}")
    lines.append(
        f"- Untracked files present on disk: {len([p for p in untracked_files if not _is_provenance_sidecar(p)])}"
    )
    lines.append(
        f"- Flat files under data/artifacts/: {len([p for p in flat_files if (not _is_metadata_file(p)) and (not _is_provenance_sidecar(p))])}"
    )
    lines.append("")

    if orphaned_provenance:
        lines.append("## Orphaned Provenance Sidecars")
        lines.append("")
        lines.append("The following `.PROVENANCE.json` files do not have their corresponding artifact file on disk:")
        lines.append("")
        for rel in sorted(orphaned_provenance):
            lines.append(f"- `{rel}`")
        lines.append("")

    lines.append("## Candidate Moves (Untracked + Flat Only)")
    lines.append("")
    lines.append("These candidates are *not* safe to apply automatically. Before any move:")
    lines.append("")
    lines.append("- Update references in docs/scripts/tests.")
    lines.append("- Add the new path to `data/artifacts/ARTIFACTS_MANIFEST.csv` if it becomes canonical.")
    lines.append("")

    if not candidates:
        lines.append("No candidate moves detected.")
        lines.append("")
    else:
        for c in candidates:
            lines.append(f"- `{c.src_rel}` -> `{c.dst_rel}` ({c.reason})")
        lines.append("")

    REPORT_PATH.parent.mkdir(parents=True, exist_ok=True)
    REPORT_PATH.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"Wrote: {REPORT_PATH.relative_to(REPO_ROOT)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
