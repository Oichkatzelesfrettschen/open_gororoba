tables = []
full_text = """
Posted on 30 Mar 2020 — CC-BY 4.0 — https://doi.org/10.36227/techrxiv.19425989.v1 — e-Prints posted on TechRxiv are preliminary reports that are not peer reviewed. They should not b...\r
Calculating fractal sets in n [?] 1 embedding dimensions without\r
the use of truncation\r
Shawn Halayka 1\r
1\r
Independent\r
October 30, 2023\r
Abstract\r
The theme of this research is an examination of the traditional multiplication operator, in the case of fractal sets in $n \\geq\r
1$ embedding dimensions. After this examination, an alternative, new multiplication operator is introduced. The traditional\r
multiplication operator has a time complexity of $O(nˆ2)$, whereas the new multiplication operator has a time complexity\r
of $O(n)$. Taking amortized costs into account, it is found that the new multiplication operator is more time-efficient where\r
$n \\geq 32$, using an optimizing C++ compiler. There is no problem, other than concerns about time complexity, with\r
the traditional multiplication operator. It was hypothesized that there would be differences between the two multiplication\r
operators. These differences, and some similarities, between the two multiplication operators are visualized in terms of fractal\r
sets, via OpenGL. The C++ and Python code is available upon request.\r
1

Calculating fractal sets in n ≥ 1 embedding dimensions\r
without the use of truncation\r
Shawn Halayka*\r
Wednesday 23rd March, 2022 17:21\r
Abstract\r
The theme of this research is an examination of the traditional multiplication oper\u0002ator, in the case of fractal sets in n ≥ 1 embedding dimensions. After this examination,\r
an alternative, new multiplication operator is introduced. The traditional multiplica\u0002tion operator has a time complexity of O(n\r
2\r
), whereas the new multiplication operator\r
has a time complexity of O(n). Taking amortized costs into account, it is found that\r
the new multiplication operator is more time-efficient where n ≥ 32, using an optimiz\u0002ing C++ compiler. There is no problem, other than concerns about time complexity,\r
with the traditional multiplication operator. It was hypothesized that there would\r
be differences between the two multiplication operators. These differences, and some\r
similarities, between the two multiplication operators are visualized in terms of fractal\r
sets, via OpenGL. The C++ and Python code is available upon request.\r
1 Introduction\r
The story of the Julia set begins with the discovery of the 2D complex numbers [1], the 4D\r
quaternions [2], and the 8D octonions [3], etc. These number types allow us to extend the\r
real numbers into more than one embedding dimension, providing data that are meant to be\r
visualized. For instance, in 1918, war veteran Gaston Julia published his trailblazing work\r
on iterative equations (e.g. self-mappings). The result is the Julia set [4,5], which is a set of\r
vertices along an input grid in nD space that satisfy one particular mathematical criterion.\r
This criterion is that, for each nD input vertex A, the magnitude\r
ℓ =\r
p\r
A0A0 + A1A1 + ... + A(n−1)A(n−1) =\r
vuutXn−1\r
i=0\r
A2\r
i\r
(1)\r
remains less than some chosen threshold value while undergoing iteration. Note that A0,\r
A1, etc. are real numbers. In essence, the magnitude is the square root of the vertex’s inner\r
*\r
Independent – sjhalayka@gmail.com\r
1

product in Euclidean (e.g., rectilinear) space. In this paper, the maximum iterations is 8,\r
and the threshold value is 4.\r
The traditional iterative equation is the non-linear polynomial\r
A\r
′ = A2 + D. (2)\r
where D is some constant.\r
After a long pause in time, during which we waited for the computational capability,\r
we come to the works of Norton and Holbrook [6, 7], in the 1980s, which revolutionized the\r
visualization of the Julia set – up until then, the quaternion Julia set had been unexplored\r
territory. The work of Hart et al. [8] did a wonderful job of ray tracing the quaternion Julia\r
set, setting the bar high for subsequent visualizations of fractals in general.\r
Inevitably, in the 1990s, the octonion Julia set was explored by Griffin and Joshi [9], and\r
by Dixon et al. [10].\r
Afterwards, Cheng and Tan, along with Wang and Sun, generalized the quaternion Julia\r
set [11,12] by allowing for a variable exponent in the iterative equation, and then Wang and\r
Jin extended this work [13] to include all embedding dimensions n ≥ 1 via truncation.\r
The Julia set continues to mystify us to this day – its complexity and beauty are without\r
rival in all of the mathematics. Up until now, those studying the Julia set have traditionally\r
stuck close to the basic number types: real, complex, quaternion, octonion, etc. This is\r
because each of these number types have a well-defined multiplication operator. There is no\r
such traditional number type in, say, 5D, unless you truncate and lose data like in [13].\r
In order to fully sidestep the missing 5D number type, we will define a new multiplication\r
operator.\r
Although we discuss the 5D number type in this paper, we could have easily enough\r
discussed any nD number type, where n ≥ 1 is not necessarily equal to a power-of-two (e.g.\r
not necessarily 1, 2, 4, 8, etc.) – the same principles apply to all embedding dimensions\r
n ≥ 1.\r
A deeper exploration of the Julia set is given in Katunin’s book [14]. Although Katunin’s\r
book, in Chapter 2.3, cautions against using the 16D sedenion, 32D pathion, etc. multipli\u0002cation operators, we find that Wang and Jin [13] make use of both the sedenion and pathion\r
multiplication operators just fine while calculating slices of 16D and 17D fractal sets.\r
2 Traditional multiplication and truncation\r
The traditional multiplication operator for octonions, where C = AB, is:\r
C0 = A0B0 − A1B1 − A2B2 − A3B3 − A4B4 − A5B5 − A6B6 − A7B7,\r
C1 = A0B1 + A1B0 + A2B3 − A3B2 + A4B5 − A5B4 − A6B7 + A7B6,\r
C2 = A0B2 − A1B3 + A2B0 + A3B1 + A4B6 + A5B7 − A6B4 − A7B5,\r
C3 = A0B3 + A1B2 − A2B1 + A3B0 + A4B7 − A5B6 + A6B5 − A7B4,\r
C4 = A0B4 − A1B5 − A2B6 − A3B7 + A4B0 + A5B1 + A6B2 + A7B3,\r
C5 = A0B5 + A1B4 − A2B7 + A3B6 − A4B1 + A5B0 − A6B3 + A7B2,\r
C6 = A0B6 + A1B7 + A2B4 − A3B5 − A4B2 + A5B3 + A6B0 − A7B1,\r
C7 = A0B7 − A1B6 + A2B5 + A3B4 − A4B3 − A5B2 + A6B1 + A7B0.\r
(3)\r
2

Note that A0, A1, etc. are real numbers.\r
For reference, we define commutativity as the satisfaction of the equality AB = BA,\r
associativity as (AB)D = A(BD), and distributivity as A(B + D) = AB + AD.\r
Note that the real multiplication is represented by the first term of the first line in Eq.\r
3. Using the aforementioned definitions, the real multiplication is commutative, associative,\r
and distributive. Additionally, the complex multiplication is represented by the first two\r
terms of the first two lines. The complex multiplication is commutative, associative, and\r
distributive. Likewise, the quaternion multiplication is represented by the first four terms of\r
the first four lines. The quaternion multiplication is not commutative, but it is associative\r
and distributive. The octonion multiplication is not commutative, but it is associative and\r
distributive.\r
For 5D traditional multiplication, like in [13], the last three components of the two\r
operands are set to 0 before each multiplication operation occurs, and the last three compo\u0002nents of the product are set to 0 after each multiplication occurs – in other words, they are\r
all truncated, and data are lost.\r
For further details on traditional multiplication, please see the books [15] and [16].\r
3 Definition of a few useful functions in nD\r
In this paper, we treat each nD vertex A as consisting of a 1D scalar A0 and an (n − 1)D\r
vector (A1, ..., A(n−1)). The magnitude measures are:\r
ℓs =\r
p\r
A0A0 + A1A1 + ... + A(n−1)A(n−1) =\r
vuutXn−1\r
i=0\r
A2\r
i\r
, (4)\r
ℓv =\r
p\r
A1A1 + ... + A(n−1)A(n−1) =\r
vuutXn−1\r
i=1\r
A2\r
i\r
. (5)\r
The C = exp(A) function calculates the exponentiation of base e (e.g. Euler’s constant):\r
C0 = exp(A0) cos(ℓv),\r
C1 =\r
A1\r
ℓv\r
exp(A0) sin(ℓv),\r
...\r
C(n−1) =\r
A(n−1)\r
ℓv\r
exp(A0) sin(ℓv).\r
(6)\r
Note that A0, A1, etc. are real numbers, and that these individual instances of exp(), cos(),\r
sin() etc. are the familiar 1D real-valued functions. The C = log(A) function calculates the\r
3

inverse of the exponentiation of base e:\r
C0 = log(ℓs),\r
C1 =\r
A1\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
,\r
...\r
C(n−1) =\r
A(n−1)\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
.\r
(7)\r
The C = sin(A) function is:\r
C0 = sin(A0) cosh(ℓv),\r
C1 =\r
A1\r
ℓv\r
cos(A0) sinh(ℓv),\r
...\r
C(n−1) =\r
A(n−1)\r
ℓv\r
cos(A0) sinh(ℓv).\r
(8)\r
For instance, where n = 5, the C = exp(A) function is:\r
C0 = exp(A0) cos(ℓv),\r
C1 =\r
A1\r
ℓv\r
exp(A0) sin(ℓv),\r
C2 =\r
A2\r
ℓv\r
exp(A0) sin(ℓv),\r
C3 =\r
A3\r
ℓv\r
exp(A0) sin(ℓv),\r
C4 =\r
A4\r
ℓv\r
exp(A0) sin(ℓv),\r
(9)\r
the C = log(A) function is:\r
C0 = log(ℓs),\r
C1 =\r
A1\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
,\r
C2 =\r
A2\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
,\r
C3 =\r
A3\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
,\r
C4 =\r
A4\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
,\r
(10)\r
4

and the C = sin(A) function is:\r
C0 = sin(A0) cosh(ℓv),\r
C1 =\r
A1\r
ℓv\r
cos(A0) sinh(ℓv),\r
C2 =\r
A2\r
ℓv\r
cos(A0) sinh(ℓv),\r
C3 =\r
A3\r
ℓv\r
cos(A0) sinh(ℓv),\r
C4 =\r
A4\r
ℓv\r
cos(A0) sinh(ℓv).\r
(11)\r
It should be noted that all we have done here is extend the 2D complex functions (a part\r
of the C++ language standard) into 5D by including three extra imaginary components.\r
4 Definition of a new multiplication operator in nD\r
For both real and complex number types, where A is not necessarily the same as B, it is\r
known that\r
C = AB = BA = exp(log(A) + log(B)). (12)\r
We nominate this identity – specifically C = exp(log(A)+log(B)) – as a new general-purpose\r
commutative, associative, and distributive multiplication operator – the multiplication op\u0002erator without actual multiplication, for any embedding dimension n ≥ 1. For instance, all\r
we need are the 5D exp() and log() functions, which we defined in the previous section, and\r
the addition operator, which in 5D where C = A + B is:\r
C0 = A0 + B0,\r
C1 = A1 + B1,\r
C2 = A2 + B2,\r
C3 = A3 + B3,\r
C4 = A4 + B4.\r
(13)\r
5 Differences and similarities in terms of the products\r
of the multiplication operators\r
With regard to the new multiplication operator C = exp(log(A)+log(B)) and the traditional\r
multiplication operator C = AB: where A = B, the products of both operators are entirely\r
similar for any n ≥ 1. It is where A ̸= B that the products are not necessarily entirely\r
similar: sometimes the products are indeed entirely similar component-wise, sometimes only\r
the magnitudes are similar, and sometimes they are not similar at all – it all depends on n\r
and the individual components of A and B.\r
5

Note that the traditional multiplication operator is generally not commutative, whereas\r
the new multiplication operator is commutative. Sets like\r
A\r
′ = sin(A) + D sin(A) (14)\r
are intriguing using both operators, and some resemblance can be seen – see Figs. 1 and\r
2 for renderings of some 3D slices of some 4D fractal sets, which are generated by setting\r
A3 = 0 before the iteration function is called.\r
Note that both the new multiplication operator and the traditional multiplication oper\u0002ator produce the same result for\r
A\r
′ = Aβ + D, (15)\r
where β is an integer. This is because Aβ and A commute, in terms of the traditional\r
multiplication operator (e.g. a special case due to the power associativity of traditional\r
multiplication, where for instance A(AA) = (AA)A). See Fig. 3 for a rendering of a 3D\r
slice of a 4D fractal set, which is generated by setting A3 = 0 before the iteration function\r
is called. Also see Figs. 4 and 5 for renderings of some 3D slices of some 5D fractal sets,\r
which are generated by setting A3 = 0 and A4 = 0 before the iteration function is called.\r
These figures were rendered with OpenGL 4, using Phong shading and a shadow map. For\r
the full details on this rendering technique, please see Wolff’s book [17]. The rendered triangle\r
meshes were generated using Paul Bourke’s marching cubes C++ implementation [18], with\r
a custom vertex interpolation function that helps to noticeably minimize aliasing.\r
Please see Figs. 6 - 9 for some graphs that compare the new multiplication product to\r
the traditional multiplication product, for A′ = A2 + D and A′ = sin(A) + D sin(A).\r
6 Conclusion\r
Here we have highlighted the existence of the Julia set in all n ≥ 1 embedding dimensions, and\r
not just a few dimensions like in the vast majority of previous works. This is accomplished\r
by introducing a new multiplication operator in all n ≥ 1 embedding dimensions. This\r
technique is important because of its applicability and novelty. For instance, we may use the\r
new multiplication operator in general, for future work on topics other than the Julia set.\r
One nice thing about the new multiplication operator is that is doesn’t rely on the\r
traditional multiplication operator. For instance, if we wished to try out, say, 9D fractals,\r
we wouldn’t need to know the sedenion’s non-commutative, non-associative, distributive\r
traditional multiplication operator.\r
One other nice thing about the new multiplication operator is that it has a time complex\u0002ity of O(n) – there is some small, constant number of multiplication operations for each of\r
the n components. This is in comparison to the traditional multiplication operator (e.g. the\r
one used in Eq. 9 in [13]), which has a time complexity of O(n\r
2\r
) – there are n multiplication\r
operations for each of the n components. The following table shows the amount of time, in\r
seconds, that it takes to perform 10, 000, 000 multiplication operations:\r
Type O(n\r
2\r
) time O(n) time\r
Octonion n = 8 1.8 4.3\r
Sedenion n = 16 2.9 4.9\r
Pathion n = 32 40.1 5.9\r
6

Results may vary, but in general, for large n (e.g. n ≥ 32), the O(n) method – the new\r
multiplication operator – is the clear winner in terms of speed. Here we used Microsoft\r
Visual C++ (e.g. cl version 19.29.30133).\r
Thus, we have reason to investigate the new multiplication operator introduced in this\r
paper, for it is truly 5D – no truncation is ever performed; no data are ever lost – and it is\r
inherently fast.\r
7 Acknowledgments\r
Thank you to Ricardo Fariello for introducing me to the quaternion pow() function. Thank\r
you to Paul Bourke for testing the math, and for coming up with preliminary figures.\r
A Appendix: Fast exponentiation of variable base with\r
the pow() function\r
There is a pow() function of time complexity O(n) that can replace many sequential multi\u0002plications where the exponent β is an integer (e.g. in the case of A multiplied by itself, again\r
and again). This makes for set calculation that is even faster than the new multiplication\r
operator, especially for large β.\r
The magnitude measures are:\r
ℓs =\r
p\r
A0A0 + A1A1 + ... + A(n−1)A(n−1) =\r
vuutXn−1\r
i=0\r
A2\r
i\r
, (16)\r
ℓv =\r
p\r
A1A1 + ... + A(n−1)A(n−1) =\r
vuutXn−1\r
i=1\r
A2\r
i\r
. (17)\r
Where θ represents an angle in radians:\r
θ = β arccos \u0012\r
A0\r
ℓs\r
\u0013\r
, (18)\r
the C = pow(A, β) function in nD is:\r
C0 = ℓ\r
β\r
s\r
cos(θ),\r
C1 =\r
A1\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ),\r
...\r
C(n−1) =\r
A(n−1)\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ).\r
(19)\r
7

For instance, where n = 5, the C = pow(A, β) function is:\r
C0 = ℓ\r
β\r
s\r
cos(θ),\r
C1 =\r
A1\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ),\r
C2 =\r
A2\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ),\r
C3 =\r
A3\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ),\r
C4 =\r
A4\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ).\r
(20)\r
See Fig. 10 for a 3D slice of the 5D Julia set, generated by using this pow() function.\r
Here we have set A3 = 0 and A4 = 0 before the iteration function is called.\r
Also, see Figs. 11 - 14 for 2D slices of the 16D Julia set. Here we have set A2 through\r
A15 to equal 0 before the iteration function is called.\r
The following table shows the amount of time, in seconds, that it takes to perform\r
10, 000, 000 multiplication operations versus 10, 000, 000 pow() operations, where β = 2:\r
Type New multiplication time pow() time\r
Octonion n = 8 4.3 2.2\r
Sedenion n = 16 4.9 2.3\r
Pathion n = 32 5.9 2.8\r
The pow() function is twice as fast as the new multiplication operator, where β = 2. As β\r
increases, the new multiplication operator becomes even slower by comparison. For instance,\r
where β = 25 for pathions, the pow() function is roughly 36 times faster than the new\r
multiplication operator.\r
This technique is important because of its applicability. For instance, the technique is\r
applicable to all linear and non-linear polynomials of the form\r
A\r
′ = XAβ + Y Aγ + ... + ZA + W. (21)\r
Only the pow() function (see Eq. 19), the new multiplication operator (see Eq. 12), and the\r
addition operator (see Eq. 13) are required.\r
Note that β need not be an integer in general, nor even a real. For instance, we leave the\r
exploration of 5D exponents for future work, where:\r
A\r
β = exp[exp[log(log(A)) + log(β)]]. (22)\r
B Appendix: Embedding versus fractal dimension\r
Note that the embedding dimension n is not the same thing as the fractal (e.g. box-counting)\r
dimension of the set or its surface.\r
The box-counting dimension is calculated easily enough for 3D slices of the 4D and 5D\r
Julia sets. One may run the magnitude data through the first half of the marching cubes\r
8

algorithm, noting whether each marched cube (e.g. box) is along the surface or inside the\r
set. The marching cubes isovalue is equal to the threshold value. If all 8 vertices of the\r
marched cube correspond to a value less than the threshold, then the box is inside the set. If\r
only some of the vertices correspond to a value less than the threshold, then the box is along\r
the surface. Finally, if none of the vertices correspond to a value less than the threshold,\r
then the box is outside the set. Count the boxes accordingly, and use the marched cube side\r
length ℓbox to gather the box-counting dimension:\r
nbox = lim\r
ℓbox→0\r
log(count(ℓbox))\r
log \u0010\r
1\r
ℓbox \u0011 . (23)\r
The basic idea is that the measure nbox will become more and more accurate as ℓbox goes to\r
zero. Note that the count is a function of the box size – the smaller the boxes, the larger\r
the count.\r
The triangles (e.g. simplices) need not be generated in the second half of the marching\r
cubes algorithm, because all of the data that we need are already encoded in the marched\r
cubes themselves. This lack of simplices makes it very straightforward to extend the first\r
half of the marching cubes algorithm to any embedding dimension n ≥ 1 (e.g. marching\r
hypercubes, where n = 4, but without the need for tetrahedra, or n = 5 but without\r
pentachora, etc.), if one is not looking for mere slices.\r
Note that the fractal dimension nbox need not be an integer like the embedding dimension\r
n is.\r
C Appendix: Artificial Intelligence\r
The emulation of traditional multiplication can be performed by an artificial intelligence,\r
namely an artificial neural network via the Python PyTorch package that performs non\u0002linear regression. Python acceleration can be enabled by using the Numba package, giving\r
speeds similar to native C++. In this paper we used Python 3.9.11, numpy 1.21.5, and\r
numba 0.55.1. Note that the artificial intelligence method is about an order or two of\r
magnitude slower than the traditional multiplication, which is to be expected. Output\r
meshes are visualized in Fig. 15, showing promise for the artificial intelligence method. The\r
meshes were generated using the Python Scikit-image package’s Lewiner marching cubes\r
implementation. We leave the exploration of hardware implementations of artificial neural\r
networks for future work.\r
9

References\r
[1] Cardano. Ars magna. 1545\r
[2] Hamilton. On quaternions; or on a new system of imaginaries in algebra. 1843\r
[3] Graves. The mathematical papers of Sir William Rowan Hamilton. 1843\r
[4] Julia. M´emoire sur l’it´eration des fonctions rationnelles. 1918\r
[5] Fatou. Sur les ´equations fonctionnelles. 1919\r
[6] Norton. Generation and display of geometric fractals in 3-D. Computer Graphics,\r
16(3):61–67, 1982\r
[7] Holbrook. Quaternionic asteroids and starfields, Applied Mathematical Notes, 8 (2), pp.\r
1-34, 1983\r
[8] Hart et al. Ray tracing deterministic 3-D fractals. Computer Graphics, 23(3):289–296,\r
1989\r
[9] Griffin and Joshi. Octonionic Julia sets. Chaos Solitons and Fractals, 2(1):11–24, 1992\r
[10] Dixon et al. Generation and graphical analysis of Mandelbrot and Julia sets in more\r
than four dimensions. Computers & Graphics, 20(3):451–456, 1996\r
[11] Cheng and Tan. Generalization of 3D Mandelbrot and Julia sets. J Zhejiang Univ Sci\r
A 2007 8(1):134-141s, 2006\r
[12] Wang and Sun. The general quaternionic M–J sets on the mapping z ← z\r
a + c (a ∈ N).\r
Computers & Mathematics with Applications, 53(11) 1718–1732, 2007\r
[13] Wang and Jin. Hyperdimensional generalized M–J sets in hypercomplex number space.\r
Nonlinear Dynamics, 73(1):843–852, 2013\r
[14] Katunin. A concise introduction to hypercomplex fractals. ISBN: 978-0367657642, 2017\r
[15] Imaeda and Imaeda, Sedenions: algebra and analysis, Applied mathematics and com\u0002putation, vol. 115, pp. 77–88, 2000.\r
[16] Morais, Georgiev, Spr¨oßig. Real Quaternionic Calculus Handbook. Basel: Birkh¨auser;\r
2014.\r
[17] Wolff. OpenGL 4 Shading Language Cookbook - 3E. ISBN: 9781789342253, 2018\r
[18] Lorensen and Cline. Marching cubes: A high resolution 3D surface construction algo\u0002rithm. ACM SIGGRAPH Computer Graphics. 21 (4): 163–169, 1987\r
10

Figure 1: A rendering of a 3D slice of a 4D (e.g. quaternion) fractal set. The iterative\r
equation is A′ = sin(A) + D sin(A), where D = (0.3, 0.5, 0.4, 0.2). The set is calculated using\r
the traditional multiplication operator.\r
11

Figure 2: A rendering of a 3D slice of a 4D fractal set. The iterative equation is A′ = sin(A)+\r
D sin(A), where D = (0.3, 0.5, 0.4, 0.2). The set is calculated using the new multiplication\r
operator.\r
12

Figure 3: A rendering of a 3D slice of the 4D Julia set. The iterative equation is A′ = A2+D,\r
where D = (0.3, 0.5, 0.4, 0.2). The set is calculated using the new multiplication operator,\r
although the traditional multiplication operator generates the same set as well.\r
13

Figure 4: A rendering of a 3D slice of the 5D Julia set. The iterative equation is A′ =\r
A2+D, where D = (0.3, 0.5, 0.4, −0.2, 0.8). The set is calculated using the new multiplication\r
operator, although the traditional multiplication operator generates the same set as well.\r
14

Figure 5: A rendering of a 3D slice of a 5D fractal set. The iterative equation is A′ = A3+D,\r
where D = (−0.3, −0.5, 0.4, −0.2, 0.1). The set is calculated using the new multiplication\r
operator, although the traditional multiplication operator generates the same set as well.\r
15

Figure 6: A graph that compares the new multiplication product’s magnitude to the tradi\u0002tional multiplication product’s magnitude. Note that the data form a straight line, which\r
means that the products’ magnitudes are equal. The iterative equation is A′ = A2 + D.\r
Figure 7: A graph that compares the new multiplication product’s first component to the\r
traditional multiplication product’s first component. Note that the data form a straight\r
line, which means that the products’ first components are equal. The products’ other four\r
components are also equal. The iterative equation is A′ = A2 + D.\r
16

Figure 8: A graph that compares the new multiplication product’s magnitude to the tradi\u0002tional multiplication product’s magnitude. Note that the data form a straight line, for the\r
most part, which means that the products’ magnitudes are equal. The iterative equation is\r
A′ = sin(A) + D sin(A).\r
Figure 9: A graph that compares the new multiplication product’s first component to the\r
traditional multiplication product’s first component. Note that the data do not form a\r
straight line, which means that the products’ first components are not necessarily equal.\r
The products’ other four components are also not necessarily equal. The iterative equation\r
is A′ = sin(A) + D sin(A).\r
17

Figure 10: A rendering of a 3D slice of the 5D Julia set. The iterative equation is A′ = A2+D,\r
where D = (0.3, 0.5, 0.4, 0.2, 0.1). The 3D slice is cut in half, and multiple isosurfaces are\r
used to show internal detail. The set is calculated using the pow() function, although both\r
the traditional multiplication and new multiplication operators generate the same set as well.\r
18

Figure 11: A rendering of a 2D slice of a 16D fractal set. The iterative equation is A′ =\r
A2 + D, where D = (0.2, 0.2, 0.3, 0.2, 0, 0.1, 0.1, 0, 0, 0.2, 0, 0.1, 0.3, 0, 0.2, 0.2). The set is\r
calculated using the pow() function, although both the traditional multiplication and new\r
multiplication operators generate the same set as well. Note that the intensity of each pixel is\r
a reflection of the magnitude, with respect to the threshold value. That is, pure white pixels\r
lie outside of the set, and rest of the pixels lie within the set. Pure black pixels correspond\r
to zero magnitude.\r
19

Figure 12: A rendering of a 2D slice of a 16D fractal set. The iterative equation is A′ =\r
A3 + D, where D = (0.2, 0.2, 0.3, 0.2, 0, 0.1, 0.1, 0, 0, 0.2, 0, 0.1, 0.3, 0, 0.2, 0.2). The set is\r
calculated using the pow() function, although both the traditional multiplication and new\r
multiplication operators generate the same set as well.\r
20

Figure 13: A rendering of a 2D slice of a 16D fractal set. The iterative equation is A′ =\r
A5.5 + D, where D = (0.2, 0.2, 0.3, 0.2, 0, 0.1, 0.1, 0, 0, 0.2, 0, 0.1, 0.3, 0, 0.2, 0.2). The set is\r
calculated using the pow() function. Note that the exponent is not an integer.\r
21

Figure 14: A rendering of a 2D slice of a 16D fractal set. The iterative equation is A′ =\r
A6 + D, where D = (0.2, 0.2, 0.3, 0.2, 0, 0.1, 0.1, 0, 0, 0.2, 0, 0.1, 0.3, 0, 0.2, 0.2). The set is\r
calculated using the pow() function, although both the traditional multiplication and new\r
multiplication operators generate the same set as well.\r
22

Figure 15: A rendering of some 3D slices of some 4D fractal sets. The iterative equation is\r
A′ = A2 + D, where D = (0.3, 0.5, 0.4, 0.2). The set on the left is calculated using artificial\r
intelligence, and the set on the right is calculated using the traditional multiplication oper\u0002ator. The aliasing in the meshes is due to the use of the standard linear vertex interpolation\r
in the Scikit-image marching cubes implementation.\r
23"""

[metadata]
title = "Pathions1"
authors = ["Unknown"]

[[sections]]
number = "0"
title = "Preamble"
text = """
Posted on 30 Mar 2020 — CC-BY 4.0 — https://doi.org/10.36227/techrxiv.19425989.v1 — e-Prints posted on TechRxiv are preliminary reports that are not peer reviewed. They should not b...\r
Calculating fractal sets in n [?] 1 embedding dimensions without\r
the use of truncation\r
Shawn Halayka 1"""

[[sections]]
number = "1"
title = "Independent"
text = """
October 30, 2023\r
Abstract\r
The theme of this research is an examination of the traditional multiplication operator, in the case of fractal sets in $n \\geq\r
1$ embedding dimensions. After this examination, an alternative, new multiplication operator is introduced. The traditional\r
multiplication operator has a time complexity of $O(nˆ2)$, whereas the new multiplication operator has a time complexity\r
of $O(n)$. Taking amortized costs into account, it is found that the new multiplication operator is more time-efficient where\r
$n \\geq 32$, using an optimizing C++ compiler. There is no problem, other than concerns about time complexity, with\r
the traditional multiplication operator. It was hypothesized that there would be differences between the two multiplication\r
operators. These differences, and some similarities, between the two multiplication operators are visualized in terms of fractal\r
sets, via OpenGL. The C++ and Python code is available upon request."""

[[sections]]
number = "1"
title = "Calculating fractal sets in n ≥ 1 embedding dimensions"
text = """
without the use of truncation\r
Shawn Halayka*\r
Wednesday 23rd March, 2022 17:21\r
Abstract\r
The theme of this research is an examination of the traditional multiplication oper\u0002ator, in the case of fractal sets in n ≥ 1 embedding dimensions. After this examination,\r
an alternative, new multiplication operator is introduced. The traditional multiplica\u0002tion operator has a time complexity of O(n\r
2\r
), whereas the new multiplication operator\r
has a time complexity of O(n). Taking amortized costs into account, it is found that\r
the new multiplication operator is more time-efficient where n ≥ 32, using an optimiz\u0002ing C++ compiler. There is no problem, other than concerns about time complexity,\r
with the traditional multiplication operator. It was hypothesized that there would\r
be differences between the two multiplication operators. These differences, and some\r
similarities, between the two multiplication operators are visualized in terms of fractal\r
sets, via OpenGL. The C++ and Python code is available upon request."""

[[sections]]
number = "1"
title = "Introduction"
text = """
The story of the Julia set begins with the discovery of the 2D complex numbers [1], the 4D\r
quaternions [2], and the 8D octonions [3], etc. These number types allow us to extend the\r
real numbers into more than one embedding dimension, providing data that are meant to be\r
visualized. For instance, in 1918, war veteran Gaston Julia published his trailblazing work\r
on iterative equations (e.g. self-mappings). The result is the Julia set [4,5], which is a set of\r
vertices along an input grid in nD space that satisfy one particular mathematical criterion.\r
This criterion is that, for each nD input vertex A, the magnitude\r
ℓ =\r
p\r
A0A0 + A1A1 + ... + A(n−1)A(n−1) =\r
vuutXn−1\r
i=0\r
A2\r
i\r
(1)\r
remains less than some chosen threshold value while undergoing iteration. Note that A0,\r
A1, etc. are real numbers. In essence, the magnitude is the square root of the vertex’s inner\r
*\r
Independent – sjhalayka@gmail.com\r
1

product in Euclidean (e.g., rectilinear) space. In this paper, the maximum iterations is 8,\r
and the threshold value is 4.\r
The traditional iterative equation is the non-linear polynomial\r
A\r
′ = A2 + D. (2)\r
where D is some constant.\r
After a long pause in time, during which we waited for the computational capability,\r
we come to the works of Norton and Holbrook [6, 7], in the 1980s, which revolutionized the\r
visualization of the Julia set – up until then, the quaternion Julia set had been unexplored\r
territory. The work of Hart et al. [8] did a wonderful job of ray tracing the quaternion Julia\r
set, setting the bar high for subsequent visualizations of fractals in general.\r
Inevitably, in the 1990s, the octonion Julia set was explored by Griffin and Joshi [9], and\r
by Dixon et al. [10].\r
Afterwards, Cheng and Tan, along with Wang and Sun, generalized the quaternion Julia\r
set [11,12] by allowing for a variable exponent in the iterative equation, and then Wang and\r
Jin extended this work [13] to include all embedding dimensions n ≥ 1 via truncation.\r
The Julia set continues to mystify us to this day – its complexity and beauty are without\r
rival in all of the mathematics. Up until now, those studying the Julia set have traditionally\r
stuck close to the basic number types: real, complex, quaternion, octonion, etc. This is\r
because each of these number types have a well-defined multiplication operator. There is no\r
such traditional number type in, say, 5D, unless you truncate and lose data like in [13].\r
In order to fully sidestep the missing 5D number type, we will define a new multiplication\r
operator.\r
Although we discuss the 5D number type in this paper, we could have easily enough\r
discussed any nD number type, where n ≥ 1 is not necessarily equal to a power-of-two (e.g.\r
not necessarily 1, 2, 4, 8, etc.) – the same principles apply to all embedding dimensions\r
n ≥ 1.\r
A deeper exploration of the Julia set is given in Katunin’s book [14]. Although Katunin’s\r
book, in Chapter 2.3, cautions against using the 16D sedenion, 32D pathion, etc. multipli\u0002cation operators, we find that Wang and Jin [13] make use of both the sedenion and pathion\r
multiplication operators just fine while calculating slices of 16D and 17D fractal sets."""

[[sections]]
number = "2"
title = "Traditional multiplication and truncation"
text = """
The traditional multiplication operator for octonions, where C = AB, is:\r
C0 = A0B0 − A1B1 − A2B2 − A3B3 − A4B4 − A5B5 − A6B6 − A7B7,\r
C1 = A0B1 + A1B0 + A2B3 − A3B2 + A4B5 − A5B4 − A6B7 + A7B6,\r
C2 = A0B2 − A1B3 + A2B0 + A3B1 + A4B6 + A5B7 − A6B4 − A7B5,\r
C3 = A0B3 + A1B2 − A2B1 + A3B0 + A4B7 − A5B6 + A6B5 − A7B4,\r
C4 = A0B4 − A1B5 − A2B6 − A3B7 + A4B0 + A5B1 + A6B2 + A7B3,\r
C5 = A0B5 + A1B4 − A2B7 + A3B6 − A4B1 + A5B0 − A6B3 + A7B2,\r
C6 = A0B6 + A1B7 + A2B4 − A3B5 − A4B2 + A5B3 + A6B0 − A7B1,\r
C7 = A0B7 − A1B6 + A2B5 + A3B4 − A4B3 − A5B2 + A6B1 + A7B0.\r
(3)"""

[[sections]]
number = "2"
title = "Note that A0, A1, etc. are real numbers."
text = """
For reference, we define commutativity as the satisfaction of the equality AB = BA,\r
associativity as (AB)D = A(BD), and distributivity as A(B + D) = AB + AD.\r
Note that the real multiplication is represented by the first term of the first line in Eq.\r
3. Using the aforementioned definitions, the real multiplication is commutative, associative,\r
and distributive. Additionally, the complex multiplication is represented by the first two\r
terms of the first two lines. The complex multiplication is commutative, associative, and\r
distributive. Likewise, the quaternion multiplication is represented by the first four terms of\r
the first four lines. The quaternion multiplication is not commutative, but it is associative\r
and distributive. The octonion multiplication is not commutative, but it is associative and\r
distributive.\r
For 5D traditional multiplication, like in [13], the last three components of the two\r
operands are set to 0 before each multiplication operation occurs, and the last three compo\u0002nents of the product are set to 0 after each multiplication occurs – in other words, they are\r
all truncated, and data are lost.\r
For further details on traditional multiplication, please see the books [15] and [16]."""

[[sections]]
number = "3"
title = "Definition of a few useful functions in nD"
text = """
In this paper, we treat each nD vertex A as consisting of a 1D scalar A0 and an (n − 1)D\r
vector (A1, ..., A(n−1)). The magnitude measures are:\r
ℓs =\r
p\r
A0A0 + A1A1 + ... + A(n−1)A(n−1) =\r
vuutXn−1\r
i=0\r
A2\r
i\r
, (4)\r
ℓv =\r
p\r
A1A1 + ... + A(n−1)A(n−1) =\r
vuutXn−1\r
i=1\r
A2\r
i\r
. (5)\r
The C = exp(A) function calculates the exponentiation of base e (e.g. Euler’s constant):\r
C0 = exp(A0) cos(ℓv),\r
C1 =\r
A1\r
ℓv\r
exp(A0) sin(ℓv),\r
...\r
C(n−1) =\r
A(n−1)\r
ℓv\r
exp(A0) sin(ℓv).\r
(6)\r
Note that A0, A1, etc. are real numbers, and that these individual instances of exp(), cos(),\r
sin() etc. are the familiar 1D real-valued functions. The C = log(A) function calculates the\r
3

inverse of the exponentiation of base e:\r
C0 = log(ℓs),\r
C1 =\r
A1\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
,\r
...\r
C(n−1) =\r
A(n−1)\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
.\r
(7)\r
The C = sin(A) function is:\r
C0 = sin(A0) cosh(ℓv),\r
C1 =\r
A1\r
ℓv\r
cos(A0) sinh(ℓv),\r
...\r
C(n−1) =\r
A(n−1)\r
ℓv\r
cos(A0) sinh(ℓv).\r
(8)\r
For instance, where n = 5, the C = exp(A) function is:\r
C0 = exp(A0) cos(ℓv),\r
C1 =\r
A1\r
ℓv\r
exp(A0) sin(ℓv),\r
C2 =\r
A2\r
ℓv\r
exp(A0) sin(ℓv),\r
C3 =\r
A3\r
ℓv\r
exp(A0) sin(ℓv),\r
C4 =\r
A4\r
ℓv\r
exp(A0) sin(ℓv),\r
(9)\r
the C = log(A) function is:\r
C0 = log(ℓs),\r
C1 =\r
A1\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
,\r
C2 =\r
A2\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
,\r
C3 =\r
A3\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
,\r
C4 =\r
A4\r
ℓv\r
arccos \u0012\r
A0\r
ℓs\r
\u0013\r
,\r
(10)\r
4

and the C = sin(A) function is:\r
C0 = sin(A0) cosh(ℓv),\r
C1 =\r
A1\r
ℓv\r
cos(A0) sinh(ℓv),\r
C2 =\r
A2\r
ℓv\r
cos(A0) sinh(ℓv),\r
C3 =\r
A3\r
ℓv\r
cos(A0) sinh(ℓv),\r
C4 =\r
A4\r
ℓv\r
cos(A0) sinh(ℓv).\r
(11)\r
It should be noted that all we have done here is extend the 2D complex functions (a part\r
of the C++ language standard) into 5D by including three extra imaginary components."""

[[sections]]
number = "4"
title = "Definition of a new multiplication operator in nD"
text = """
For both real and complex number types, where A is not necessarily the same as B, it is\r
known that\r
C = AB = BA = exp(log(A) + log(B)). (12)\r
We nominate this identity – specifically C = exp(log(A)+log(B)) – as a new general-purpose\r
commutative, associative, and distributive multiplication operator – the multiplication op\u0002erator without actual multiplication, for any embedding dimension n ≥ 1. For instance, all\r
we need are the 5D exp() and log() functions, which we defined in the previous section, and\r
the addition operator, which in 5D where C = A + B is:\r
C0 = A0 + B0,\r
C1 = A1 + B1,\r
C2 = A2 + B2,\r
C3 = A3 + B3,\r
C4 = A4 + B4.\r
(13)"""

[[sections]]
number = "5"
title = "Differences and similarities in terms of the products"
text = """
of the multiplication operators\r
With regard to the new multiplication operator C = exp(log(A)+log(B)) and the traditional\r
multiplication operator C = AB: where A = B, the products of both operators are entirely\r
similar for any n ≥ 1. It is where A ̸= B that the products are not necessarily entirely\r
similar: sometimes the products are indeed entirely similar component-wise, sometimes only\r
the magnitudes are similar, and sometimes they are not similar at all – it all depends on n\r
and the individual components of A and B.\r
5

Note that the traditional multiplication operator is generally not commutative, whereas\r
the new multiplication operator is commutative. Sets like\r
A\r
′ = sin(A) + D sin(A) (14)\r
are intriguing using both operators, and some resemblance can be seen – see Figs. 1 and\r
2 for renderings of some 3D slices of some 4D fractal sets, which are generated by setting\r
A3 = 0 before the iteration function is called.\r
Note that both the new multiplication operator and the traditional multiplication oper\u0002ator produce the same result for\r
A\r
′ = Aβ + D, (15)\r
where β is an integer. This is because Aβ and A commute, in terms of the traditional\r
multiplication operator (e.g. a special case due to the power associativity of traditional\r
multiplication, where for instance A(AA) = (AA)A). See Fig. 3 for a rendering of a 3D\r
slice of a 4D fractal set, which is generated by setting A3 = 0 before the iteration function\r
is called. Also see Figs. 4 and 5 for renderings of some 3D slices of some 5D fractal sets,\r
which are generated by setting A3 = 0 and A4 = 0 before the iteration function is called.\r
These figures were rendered with OpenGL 4, using Phong shading and a shadow map. For\r
the full details on this rendering technique, please see Wolff’s book [17]. The rendered triangle\r
meshes were generated using Paul Bourke’s marching cubes C++ implementation [18], with\r
a custom vertex interpolation function that helps to noticeably minimize aliasing.\r
Please see Figs. 6 - 9 for some graphs that compare the new multiplication product to\r
the traditional multiplication product, for A′ = A2 + D and A′ = sin(A) + D sin(A)."""

[[sections]]
number = "6"
title = "Conclusion"
text = """
Here we have highlighted the existence of the Julia set in all n ≥ 1 embedding dimensions, and\r
not just a few dimensions like in the vast majority of previous works. This is accomplished\r
by introducing a new multiplication operator in all n ≥ 1 embedding dimensions. This\r
technique is important because of its applicability and novelty. For instance, we may use the\r
new multiplication operator in general, for future work on topics other than the Julia set.\r
One nice thing about the new multiplication operator is that is doesn’t rely on the\r
traditional multiplication operator. For instance, if we wished to try out, say, 9D fractals,\r
we wouldn’t need to know the sedenion’s non-commutative, non-associative, distributive\r
traditional multiplication operator.\r
One other nice thing about the new multiplication operator is that it has a time complex\u0002ity of O(n) – there is some small, constant number of multiplication operations for each of\r
the n components. This is in comparison to the traditional multiplication operator (e.g. the\r
one used in Eq. 9 in [13]), which has a time complexity of O(n\r
2\r
) – there are n multiplication\r
operations for each of the n components. The following table shows the amount of time, in\r
seconds, that it takes to perform 10, 000, 000 multiplication operations:\r
Type O(n\r
2\r
) time O(n) time\r
Octonion n = 8 1.8 4.3\r
Sedenion n = 16 2.9 4.9\r
Pathion n = 32 40.1 5.9\r
6

Results may vary, but in general, for large n (e.g. n ≥ 32), the O(n) method – the new\r
multiplication operator – is the clear winner in terms of speed. Here we used Microsoft\r
Visual C++ (e.g. cl version 19.29.30133).\r
Thus, we have reason to investigate the new multiplication operator introduced in this\r
paper, for it is truly 5D – no truncation is ever performed; no data are ever lost – and it is\r
inherently fast."""

[[sections]]
number = "7"
title = "Acknowledgments"
text = """
Thank you to Ricardo Fariello for introducing me to the quaternion pow() function. Thank\r
you to Paul Bourke for testing the math, and for coming up with preliminary figures.\r
A Appendix: Fast exponentiation of variable base with\r
the pow() function\r
There is a pow() function of time complexity O(n) that can replace many sequential multi\u0002plications where the exponent β is an integer (e.g. in the case of A multiplied by itself, again\r
and again). This makes for set calculation that is even faster than the new multiplication\r
operator, especially for large β.\r
The magnitude measures are:\r
ℓs =\r
p\r
A0A0 + A1A1 + ... + A(n−1)A(n−1) =\r
vuutXn−1\r
i=0\r
A2\r
i\r
, (16)\r
ℓv =\r
p\r
A1A1 + ... + A(n−1)A(n−1) =\r
vuutXn−1\r
i=1\r
A2\r
i\r
. (17)\r
Where θ represents an angle in radians:\r
θ = β arccos \u0012\r
A0\r
ℓs\r
\u0013\r
, (18)\r
the C = pow(A, β) function in nD is:\r
C0 = ℓ\r
β\r
s\r
cos(θ),\r
C1 =\r
A1\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ),\r
...\r
C(n−1) =\r
A(n−1)\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ).\r
(19)"""

[[sections]]
number = "7"
title = "For instance, where n = 5, the C = pow(A, β) function is:"
text = """
C0 = ℓ\r
β\r
s\r
cos(θ),\r
C1 =\r
A1\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ),\r
C2 =\r
A2\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ),\r
C3 =\r
A3\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ),\r
C4 =\r
A4\r
ℓv\r
ℓ\r
β\r
s\r
sin(θ).\r
(20)\r
See Fig. 10 for a 3D slice of the 5D Julia set, generated by using this pow() function.\r
Here we have set A3 = 0 and A4 = 0 before the iteration function is called.\r
Also, see Figs. 11 - 14 for 2D slices of the 16D Julia set. Here we have set A2 through\r
A15 to equal 0 before the iteration function is called.\r
The following table shows the amount of time, in seconds, that it takes to perform\r
10, 000, 000 multiplication operations versus 10, 000, 000 pow() operations, where β = 2:\r
Type New multiplication time pow() time\r
Octonion n = 8 4.3 2.2\r
Sedenion n = 16 4.9 2.3\r
Pathion n = 32 5.9 2.8\r
The pow() function is twice as fast as the new multiplication operator, where β = 2. As β\r
increases, the new multiplication operator becomes even slower by comparison. For instance,\r
where β = 25 for pathions, the pow() function is roughly 36 times faster than the new\r
multiplication operator.\r
This technique is important because of its applicability. For instance, the technique is\r
applicable to all linear and non-linear polynomials of the form\r
A\r
′ = XAβ + Y Aγ + ... + ZA + W. (21)\r
Only the pow() function (see Eq. 19), the new multiplication operator (see Eq. 12), and the\r
addition operator (see Eq. 13) are required.\r
Note that β need not be an integer in general, nor even a real. For instance, we leave the\r
exploration of 5D exponents for future work, where:\r
A\r
β = exp[exp[log(log(A)) + log(β)]]. (22)\r
B Appendix: Embedding versus fractal dimension\r
Note that the embedding dimension n is not the same thing as the fractal (e.g. box-counting)\r
dimension of the set or its surface.\r
The box-counting dimension is calculated easily enough for 3D slices of the 4D and 5D\r
Julia sets. One may run the magnitude data through the first half of the marching cubes\r
8

algorithm, noting whether each marched cube (e.g. box) is along the surface or inside the\r
set. The marching cubes isovalue is equal to the threshold value. If all 8 vertices of the\r
marched cube correspond to a value less than the threshold, then the box is inside the set. If\r
only some of the vertices correspond to a value less than the threshold, then the box is along\r
the surface. Finally, if none of the vertices correspond to a value less than the threshold,\r
then the box is outside the set. Count the boxes accordingly, and use the marched cube side\r
length ℓbox to gather the box-counting dimension:\r
nbox = lim\r
ℓbox→0\r
log(count(ℓbox))\r
log \u0010\r
1\r
ℓbox \u0011 . (23)\r
The basic idea is that the measure nbox will become more and more accurate as ℓbox goes to\r
zero. Note that the count is a function of the box size – the smaller the boxes, the larger\r
the count.\r
The triangles (e.g. simplices) need not be generated in the second half of the marching\r
cubes algorithm, because all of the data that we need are already encoded in the marched\r
cubes themselves. This lack of simplices makes it very straightforward to extend the first\r
half of the marching cubes algorithm to any embedding dimension n ≥ 1 (e.g. marching\r
hypercubes, where n = 4, but without the need for tetrahedra, or n = 5 but without\r
pentachora, etc.), if one is not looking for mere slices.\r
Note that the fractal dimension nbox need not be an integer like the embedding dimension\r
n is.\r
C Appendix: Artificial Intelligence\r
The emulation of traditional multiplication can be performed by an artificial intelligence,\r
namely an artificial neural network via the Python PyTorch package that performs non\u0002linear regression. Python acceleration can be enabled by using the Numba package, giving\r
speeds similar to native C++. In this paper we used Python 3.9.11, numpy 1.21.5, and\r
numba 0.55.1. Note that the artificial intelligence method is about an order or two of\r
magnitude slower than the traditional multiplication, which is to be expected. Output\r
meshes are visualized in Fig. 15, showing promise for the artificial intelligence method. The\r
meshes were generated using the Python Scikit-image package’s Lewiner marching cubes\r
implementation. We leave the exploration of hardware implementations of artificial neural\r
networks for future work."""

[[sections]]
number = "9"
title = "References"
text = """
[1] Cardano. Ars magna. 1545\r
[2] Hamilton. On quaternions; or on a new system of imaginaries in algebra. 1843\r
[3] Graves. The mathematical papers of Sir William Rowan Hamilton. 1843\r
[4] Julia. M´emoire sur l’it´eration des fonctions rationnelles. 1918\r
[5] Fatou. Sur les ´equations fonctionnelles. 1919\r
[6] Norton. Generation and display of geometric fractals in 3-D. Computer Graphics,\r
16(3):61–67, 1982\r
[7] Holbrook. Quaternionic asteroids and starfields, Applied Mathematical Notes, 8 (2), pp.\r
1-34, 1983\r
[8] Hart et al. Ray tracing deterministic 3-D fractals. Computer Graphics, 23(3):289–296,\r
1989\r
[9] Griffin and Joshi. Octonionic Julia sets. Chaos Solitons and Fractals, 2(1):11–24, 1992\r
[10] Dixon et al. Generation and graphical analysis of Mandelbrot and Julia sets in more\r
than four dimensions. Computers & Graphics, 20(3):451–456, 1996\r
[11] Cheng and Tan. Generalization of 3D Mandelbrot and Julia sets. J Zhejiang Univ Sci\r
A 2007 8(1):134-141s, 2006\r
[12] Wang and Sun. The general quaternionic M–J sets on the mapping z ← z\r
a + c (a ∈ N).\r
Computers & Mathematics with Applications, 53(11) 1718–1732, 2007\r
[13] Wang and Jin. Hyperdimensional generalized M–J sets in hypercomplex number space.\r
Nonlinear Dynamics, 73(1):843–852, 2013\r
[14] Katunin. A concise introduction to hypercomplex fractals. ISBN: 978-0367657642, 2017\r
[15] Imaeda and Imaeda, Sedenions: algebra and analysis, Applied mathematics and com\u0002putation, vol. 115, pp. 77–88, 2000.\r
[16] Morais, Georgiev, Spr¨oßig. Real Quaternionic Calculus Handbook. Basel: Birkh¨auser;\r
2014.\r
[17] Wolff. OpenGL 4 Shading Language Cookbook - 3E. ISBN: 9781789342253, 2018\r
[18] Lorensen and Cline. Marching cubes: A high resolution 3D surface construction algo\u0002rithm. ACM SIGGRAPH Computer Graphics. 21 (4): 163–169, 1987\r
10

Figure 1: A rendering of a 3D slice of a 4D (e.g. quaternion) fractal set. The iterative\r
equation is A′ = sin(A) + D sin(A), where D = (0.3, 0.5, 0.4, 0.2). The set is calculated using\r
the traditional multiplication operator.\r
11

Figure 2: A rendering of a 3D slice of a 4D fractal set. The iterative equation is A′ = sin(A)+\r
D sin(A), where D = (0.3, 0.5, 0.4, 0.2). The set is calculated using the new multiplication\r
operator.\r
12

Figure 3: A rendering of a 3D slice of the 4D Julia set. The iterative equation is A′ = A2+D,\r
where D = (0.3, 0.5, 0.4, 0.2). The set is calculated using the new multiplication operator,\r
although the traditional multiplication operator generates the same set as well.\r
13

Figure 4: A rendering of a 3D slice of the 5D Julia set. The iterative equation is A′ =\r
A2+D, where D = (0.3, 0.5, 0.4, −0.2, 0.8). The set is calculated using the new multiplication\r
operator, although the traditional multiplication operator generates the same set as well.\r
14

Figure 5: A rendering of a 3D slice of a 5D fractal set. The iterative equation is A′ = A3+D,\r
where D = (−0.3, −0.5, 0.4, −0.2, 0.1). The set is calculated using the new multiplication\r
operator, although the traditional multiplication operator generates the same set as well.\r
15

Figure 6: A graph that compares the new multiplication product’s magnitude to the tradi\u0002tional multiplication product’s magnitude. Note that the data form a straight line, which\r
means that the products’ magnitudes are equal. The iterative equation is A′ = A2 + D.\r
Figure 7: A graph that compares the new multiplication product’s first component to the\r
traditional multiplication product’s first component. Note that the data form a straight\r
line, which means that the products’ first components are equal. The products’ other four\r
components are also equal. The iterative equation is A′ = A2 + D.\r
16

Figure 8: A graph that compares the new multiplication product’s magnitude to the tradi\u0002tional multiplication product’s magnitude. Note that the data form a straight line, for the\r
most part, which means that the products’ magnitudes are equal. The iterative equation is\r
A′ = sin(A) + D sin(A).\r
Figure 9: A graph that compares the new multiplication product’s first component to the\r
traditional multiplication product’s first component. Note that the data do not form a\r
straight line, which means that the products’ first components are not necessarily equal.\r
The products’ other four components are also not necessarily equal. The iterative equation\r
is A′ = sin(A) + D sin(A).\r
17

Figure 10: A rendering of a 3D slice of the 5D Julia set. The iterative equation is A′ = A2+D,\r
where D = (0.3, 0.5, 0.4, 0.2, 0.1). The 3D slice is cut in half, and multiple isosurfaces are\r
used to show internal detail. The set is calculated using the pow() function, although both\r
the traditional multiplication and new multiplication operators generate the same set as well.\r
18

Figure 11: A rendering of a 2D slice of a 16D fractal set. The iterative equation is A′ =\r
A2 + D, where D = (0.2, 0.2, 0.3, 0.2, 0, 0.1, 0.1, 0, 0, 0.2, 0, 0.1, 0.3, 0, 0.2, 0.2). The set is\r
calculated using the pow() function, although both the traditional multiplication and new\r
multiplication operators generate the same set as well. Note that the intensity of each pixel is\r
a reflection of the magnitude, with respect to the threshold value. That is, pure white pixels\r
lie outside of the set, and rest of the pixels lie within the set. Pure black pixels correspond\r
to zero magnitude.\r
19

Figure 12: A rendering of a 2D slice of a 16D fractal set. The iterative equation is A′ =\r
A3 + D, where D = (0.2, 0.2, 0.3, 0.2, 0, 0.1, 0.1, 0, 0, 0.2, 0, 0.1, 0.3, 0, 0.2, 0.2). The set is\r
calculated using the pow() function, although both the traditional multiplication and new\r
multiplication operators generate the same set as well.\r
20

Figure 13: A rendering of a 2D slice of a 16D fractal set. The iterative equation is A′ =\r
A5.5 + D, where D = (0.2, 0.2, 0.3, 0.2, 0, 0.1, 0.1, 0, 0, 0.2, 0, 0.1, 0.3, 0, 0.2, 0.2). The set is\r
calculated using the pow() function. Note that the exponent is not an integer.\r
21

Figure 14: A rendering of a 2D slice of a 16D fractal set. The iterative equation is A′ =\r
A6 + D, where D = (0.2, 0.2, 0.3, 0.2, 0, 0.1, 0.1, 0, 0, 0.2, 0, 0.1, 0.3, 0, 0.2, 0.2). The set is\r
calculated using the pow() function, although both the traditional multiplication and new\r
multiplication operators generate the same set as well.\r
22

Figure 15: A rendering of some 3D slices of some 4D fractal sets. The iterative equation is\r
A′ = A2 + D, where D = (0.3, 0.5, 0.4, 0.2). The set on the left is calculated using artificial\r
intelligence, and the set on the right is calculated using the traditional multiplication oper\u0002ator. The aliasing in the meshes is due to the use of the standard linear vertex interpolation\r
in the Scikit-image marching cubes implementation.\r
23"""

[[equations]]
latex = """
n \\geq\r
1"""
display = false

[[equations]]
latex = "O(nˆ2)"
display = false

[[equations]]
latex = "O(n)"
display = false

[[equations]]
latex = 'n \geq 32'
display = false

[[figures]]
label = "fig:1"
page_num = 12
image_path = "images/image_p12_1.png"

[[figures]]
label = "fig:2"
page_num = 13
image_path = "images/image_p13_2.png"

[[figures]]
label = "fig:3"
page_num = 14
image_path = "images/image_p14_3.png"

[[figures]]
label = "fig:4"
page_num = 15
image_path = "images/image_p15_4.png"

[[figures]]
label = "fig:5"
page_num = 16
image_path = "images/image_p16_5.png"

[[figures]]
label = "fig:6"
page_num = 17
image_path = "images/image_p17_6.png"

[[figures]]
label = "fig:7"
page_num = 17
image_path = "images/image_p17_7.png"

[[figures]]
label = "fig:8"
page_num = 18
image_path = "images/image_p18_8.png"

[[figures]]
label = "fig:9"
page_num = 18
image_path = "images/image_p18_9.png"

[[figures]]
label = "fig:10"
page_num = 19
image_path = "images/image_p19_10.png"

[[figures]]
label = "fig:11"
page_num = 20
image_path = "images/image_p20_11.png"

[[figures]]
label = "fig:12"
page_num = 21
image_path = "images/image_p21_12.png"

[[figures]]
label = "fig:13"
page_num = 22
image_path = "images/image_p22_13.png"

[[figures]]
label = "fig:14"
page_num = 23
image_path = "images/image_p23_14.png"

[[figures]]
label = "fig:15"
page_num = 24
image_path = "images/image_p24_15.png"
